# 内存

## 内存基本知识

存放数据，程序在执行前需要先放到内存中才能被CPU处理执行，缓和CPU与硬盘之间的速度问题。

### 内存地址表示

一个4GB的内存等于
$$
4GB = 2^{30} \times 2^2 = 2^{32}
$$
需要32位bit来指向内存中的所有地址。

### 虚拟地址和物理地址

物理地址：内存的真实地址

虚拟地址（逻辑地址）：一个程序通常把整个内存看作是自己的，即该程序的第一条指令从逻辑地址0开始。但实际上它的物理地址可能在任意位置。需要通过不同的策略来转化逻辑地址和物理地址。

### 三种策略

三种装入内存的策略

- 绝对装入
- 可重定位装入（静态重定位）
- 动态运行时装入（动态重定位）

#### 绝对装入

在编译时，如果知道程序将放在内存中的哪个位置，编译程序将会为目标代码产生**绝对地址**。在加载程序时，根据绝对地址将代码写入内存中。

该策略只适用于**单道程序环境**。灵活性差，固定的绝对地址对机器的适配性很差。很难实现在多台计算机上执行。

#### 静态重定位（可重定位装入）

在编译程序时，为程序提供从0地址开始的逻辑连续地址。在装入内存时，可根据内存的当前情况，为逻辑地址添加一个偏移量，即为内存中物理地址。
$$
逻辑地址 \space+\space 偏移量_{OFFSET} \space=\space 物理地址
$$
此策略提高的程序的灵活性，可在多台计算机上运行。缺点是需要在内存中，一次性加载所有指令（代码），如果内存没有足够的空间，就无法运行此程序。

#### 动态重定位（动态运行时装入）

和静态重定位类似，程序以逻辑地位0开始，在程序加载到内存的过程中，存在一个**重定位寄存器**，它将记录**程序在内存中的起始位置**，在后续的加载中，只需要将逻辑地址和重定位寄存器内的值进行相加，生成新的物理地址。
$$
逻辑地址 \space+\space 重定位寄存器的值_{OFFSET} \space=\space 物理地址
$$
这使得程序可以在不连续的内存空间中运行，每次执行一个指令时，只需要将指令的逻辑地址与寄存器内的值相加获得新的物理地址。同时，程序所需加载到内存中的大小可以超过真实的物理内存大小。

## 从写程序到程序运行

1. 程序员通过各种文本编辑器写出**源代码**
2. 编译器将各个源代码转化为各个**模块**，每个目标模块都是从**0开始的逻辑地址**，相互独立，
3. 通过链接，将各个目标模块组装起来，形成一个模块，即为**可执行文件**。可执行文件拥有一个**完整的逻辑地址**。组装时，也会导入各个模块所引用的库函数，例如:stdio.h。
4. 根据不同的策略将程序装入内存，生成物理地址。

![image-20240608111126777](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158212.png)

### 三种链接方式

#### 静态链接

在程序运行之前，先将各个目标模块及他们所需的库函数链接成一个完整的可执行文件，装入模块。装入后不可拆分。

![image-20240608111438924](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158468.png)

#### 装入时动态链接

在各个模块加载的内存中时，才会链接模块所需要的库函数。其物理地址是一边装入一边形成的。

![image-20240608111610170](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158710.png)

#### 运行时动态链接

在程序执行时，只将必要运行的模块加载到内存中，加载时，对其模块进行链接。但如果一个模块没有被执行，即没有被加载到内存时，该模块不会被链接且不被加载到内存中。

![image-20240608111855121](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158324.png)

## 内存管理

- 操作系统负责内存空间的分配和回收

- 虚拟内存的使用和管理，对内存空间进行扩充

- 地址转换，程序员负责编写指令，数据的逻辑地址。转换为物理地址由操作系统负责，即上述中的三种装入方式。
- 内存保护，操作系统需要保证各个进程在各自的存储空间内运行，互不干扰。

### 内存保护

#### 1.上下限寄存器

在CPU中设置一对上、下限寄存器，存放进程的起始地址和结尾地址，进程指令要访问某一个地址时，CPU会检查该指令是否越界。

#### 2.重定位寄存器和界地址寄存器

重定位寄存器存放进程的**起始地址**，界地址寄存器（限长寄存器）存放进程的**最大逻辑地址**。

CPU执行过程：

1. 当进程想要访问一个逻辑地址时，该逻辑地址会先和界地址寄存器进行对比，如果没越界，则合法；如果越界，则抛出异常。
2. 合法的逻辑地址会和重定位寄存器的起始地址相加，访问真实的物理地址。

![image-20240609112758055](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091128131.png)

### 内存空间的扩充

- 覆盖技术
- 交换技术
- 虚拟存储技术

#### 覆盖技术

覆盖技术解决了程序大小超过物理内存的问题。

覆盖技术思想：将程序分为多个段（模块），常用的段常驻在内存中，不常用的段在需要时调入内存。

内存中分成一个固定区，和若干个覆盖区。在**固定区**内的指令，一旦调入后则**不能被调出**（除非程序结束）；覆盖区则在需要时调入/调出内存。

![image-20240609113707118](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091137169.png)

覆盖技术必须由程序员声明覆盖结构，操作系统完成自动覆盖。

缺点：对用户不透明，增加了编程负担。

只有早期的操作系统采用这种技术，已经成为历史。

#### 交换（对换）技术

思想：在内存空间紧张时，系统将内存中某些进程暂时换出到外存（硬盘等），把外村中某些已具备运行条件的进程换入内存中

当进程被换出到外村时，内存会保留被换出的进程的PCB（Process Control Block），PCB中保留了被换出进程的必要信息，例如在磁盘的位置等。随后将这些PCB挂起队列，即中级调度（内存调度），决定哪个处于挂起状态的进程重新调入内存。

![image-20240609114718386](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091147431.png)

问题：

1. 应该在外存的什么位置保存被换出的进程？
2. 什么时候换出？
3. 应该换出那些进程？

答：

1. 在电脑的磁盘中，磁盘被分为两个区域：对换区和文件区。

   文件区：追求存储空间的利用率，对文件区采用的是**离散分配方式**

   对换区：只占磁盘空间的小部分。对换的速度直接影响系统的整体速度，因此对换区追求换入换出的速度，通常对换区采用**连续分配的方式**。

2. 交换通常在许多进程运行且内存吃紧时进行，直到系统负荷降低。例如：许多进程运行时频繁发生缺页，说明内存吃紧，此时可以换出一些进程，直到缺页率明显下降时，暂停换出。

3. 可优先换出阻塞进程，或换出优先级较低的进程。但为了避免优先级较低的进程发生**饥饿现象**，即调入内存后很快又被换出，通常还会考虑进程在内存的**驻留时间**。

PCB会常驻内存，不会被换出。

### 内存空间的分配与回收

#### 连续分配管理

- 单一连续分配
- 固定分区分配
- 动态分区分配

连续分配：系统为用户进程分配的必须是一个**连续的内存空间**

##### 单一连续分配

在单一连续分配中，内存被分为**系统区**和**用户区**。

系统区：通常位于内存的**低地址**部分，用于存放**操作系统的相关数据**；

用户区：用于存放用户进程的相关数据。在单一连续分配中，内存只允许存在**一道用户程序**，即用户程序独占整个用户空间。

优点：实现简单，**无外部碎片**。可以采用覆盖技术扩充内存，不一定需要内存保护。

缺点：只适合单用户单任务的操作系统，不支持多道程序并发运行。存在**内部碎片**，降低存储器的利用率。

![image-20240609150935730](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091509770.png)

- 内部碎片：操作系统为一个进程分配了一段内存空间 ，用户程序并没有使用全部被分配到的内存空间，存在一些空间没有被利用。
  $$
  内部碎片\space = \space 被分配的内存空间 \space - 实际使用的空间
  $$

- 外部碎片：内存中，分配给进程的空间并不是完全连续的，进程之间存在一些细小的空间，这些空间较小且无法分配给别的进程，即为外部碎片。

##### 固定分区分配

为了支持多道程序，内存中需要装入多到程序。于是将内存划分为若干个大小的分区，每个分区只允许装入一个程序。

分区可以是大小**相等**的分区，也可以是大小**固定但不同**的分区。

![image-20240609152551701](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091525744.png)

相等：**缺乏灵活性**，程序之间的大小可能并不相同。但这种设计适合于控制**多个相同程序**的场合。

分区大小不同：增加了灵活性。

在固定分区分配中，操作系统需要建立一个**分区说明表**，来实现各个分区的分配和回收。

![image-20240609153618464](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091536508.png)

当某用户程序要装入内存时，由操作系统内核根据用户程序大小检索该表，从中找到一个能满足大小的、未被分配的分区，分配给该程序，然后将状态修改为已分配。

优点：实现简单，无外部碎片。

缺点：

1. 当程序太大时，可能没有一个分区满足该进程的需求，此时不得不采用覆盖技术来解决，但覆盖技术需要付出一定的时间代价。
2. 当程序小于分区大小，由于程序独占一个分区，会产生内部碎片。

##### 动态分区分配

动态分区分配也称为可变分区分配。

在程序装入内存时，根据进程的大小动态建立分区，该分区的大小正好适合装入进程。

![image-20240609154704409](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091547457.png)

问题：

1. 系统需要用什么样的数据结构记录内存的使用情况？
2. 当多个空闲分区都满足装入需求时，该选择哪个分区进行分配呢？

![image-20240609154811643](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091548682.png)

3. 如何进行分区的分配和回收操作呢？

答：

1. 两种数据结构来记录内存使用情况：

   - 空闲分区表：每个空闲分区都对应一个表项，表项包括分区号、分区大小、分区起始地址等信息

     ![image-20240609155115389](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091551450.png)

   - 空闲分区链：通过链表的形式，每个链表结构含有两个指针，指针分别指向地址更低的空闲分区的结束地址和下一个分区的起始地址。除外在分区的起始部分还可以记录分区大小等分区信息。

     ![image-20240609155712906](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091557948.png)

2. 当一个进程在被装入时，存在多个分区满足此进程，需要通过**动态分区分配算法**，从空闲分区表/链 中，选择一个分区分配给该进程。

3. 分配时，通过不同的动态分区分配算法：

   - 决定分配一个**空间大于此进程的分区**时，在分区表内减去被分配的空间，其**分区的数量仍然保持不变**。

     ![image-20240609160454078](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091604155.png)

   - 分配一个空间大小等于某个分区空间时，在表项内删除此分区，分区数量减1.

     ![image-20240609160636476](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091606540.png)

   回收时，

   - 当回收的进程存在一个相邻的空闲分区，则将回收后的空间添加到相邻的分区，并合并为一个分区。

     ![image-20240609160901581](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091609210.png)

   - 当回收的进程存在两个相邻的空闲分区，则将这三个分区全部合并为一个分区。

     ![image-20240609161107269](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091611322.png)

   - 当回收的进程不存在一个相邻的空闲分区，则在分区表内添加一个新的表项。

     ![image-20240609161234363](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091612409.png)

   注意：分区表的排序不一定时按照地址的递增顺序排列，具体的排列方式根据不同的动态分区分配算法来决定。

   

外部碎片解决方案

通过紧凑技术（Compaction）：利用换入\换出技术，将进程进行上下平移，此时碎片空间都会被向外挤出，形成一个大的空闲分区。重定位寄存器，保存进程新的起始物理地址，完成紧凑技术。

换入换出：

![image-20240609162825915](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091628972.png)

![image-20240609162901321](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091629362.png)

#### 动态分区分配算法

在多个空闲分区能够被满足时，选择哪个分区进行分配？以下算法提供解决方案：

- 首次适应算法：First Fit
- 最佳适应算法：Best Fit
- 最坏适应算法：Worst Fit
- 邻近适应算法：Next Fit

##### 首次适应算法 First Fit

思想：每次从低地址开始查找，找到第一个能够满足大小的空闲分区

实现：空闲分区**从低地址开始递增排序**，每次分配内存时按顺序查找空闲分区链（或空闲分区表），配分**第一个大小能够满足的分区**。

![image-20240612143132788](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121431963.png)

##### 最佳适应算法 Best Fit

思想：为了保证较大的进程有完整连续空间，最佳适应算法会优先分配能够满足进程的最小分区

实现：空闲分区按照**容量递增排序**，每次分配内存时按顺序查找，找到**第一个能适配的分区**（最小的满足分配的分区）进行配分，分配后，需要对空闲分区表（链）进行重新排序。

![image-20240612144026750](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121440204.png)

缺点：随着分配进程增多，内存内会产生很多外部碎片

##### 最坏适应算法 Worst Fit

思想：和最佳适应算法相反，每次分配最大的分区

实现：空闲分区按照**容量递减排序**，每次分配内存时按顺序查找，找到**第一个能适配的分区**（最大的满足分配的分区）进行配分，分配后，需要对空闲分区表（链）进行重新排序。

当第一个内存满足不了的话，那就意味着没有一个分区能够分配给该进程。

![image-20240612145150082](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121451757.png)

缺点：由于大分区不断被分配，若在某一时刻有一个较大的进程需要被分配空间时，则没有分区能够被满足

##### 邻近适应算法 Next Fit

思想：由于首次适应算法每次都得从低地址开始查找，当低地址存在太多碎片时，每次查找都得经过这些地址，极大浪费了查找时间。因此，在查找时，**从上次结束的地址开始查找**，减少了查找时间。

实现：将空闲分区按照地址递增顺序排列，每次分配从上一个结束的位置开始查找。

![image-20240612150622985](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121506625.png)

缺点：与首次适应算法相比，当低地址存在一个小分区刚好满足新的进程时，邻近适应算法无法优先考虑低地址的分区，且破坏了大分区。

##### 总结

![image-20240612150941709](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121509280.png)

#### 非连续分配管理

- 基本分页存储管理
- 基本分段存储管理
- 段页式存储管理

##### 基本分页存储管理

将内存空间分为一个个大小相等的分区（比如每个分区4KB），每个分区就是一**页帧**（frame），每个页帧都有一个编号**页帧号**。（页框，页帧，内存块，物理块，物理页号），页帧号从0开始。

![image-20240612151637507](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121516910.png)

操作系统会将进程的**逻辑地址空间**分为与**页帧大小相等**的多个**页**，每个页都有自己的**页号**，也是从0开始。

![image-20240612151953624](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121519963.png)

进程的各个页都会被放在内存的页帧中。

![image-20240612152041802](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121520174.png)

###### 页表

为了能够知道进程的每个页面在内存中存放的位置，OS需要对每个进程建立一张**页表**，通常存放在PCB中。

![image-20240612152435877](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121524310.png)

页表结构

块号表示：

以一个4GB大小的内存为例，内存的页帧大小为4KB，则有
$$
页帧总数 = 2^{32} \div 2^{12} = 2^{20}页
$$
自此，我们可以使用20个bit来表示内存中所有的页帧地址，内存页帧的范围在 2^{20} - 1。

所以，块号大小为20bit，但通常计算机以字节byte为单位，即为3byte = 3B

页号：

页号不需要占空间。当我们需要某个**页i的地址**时，通过公式
$$
页_{i地址} = X_{页表在内存中的起始地址} + 3_{byte} \times i
$$
注意！页表记录的是内存块号，而不是内存块的起始地址。
$$
j_{页起始地址}= j \times 4KB_{内存块大小}
$$

###### 地址转换

进程非连续分配，但页内的地址是连续存放的。

当我们要访问某个逻辑地址A时：

1. 确定逻辑地址A对应的页号P
2. 根据页号查询页表，算出该页的起始地址
3. 确定逻辑地址A，相对于页内的偏移量W是多少

$$
物理地址_{逻辑地址A}=P_{页号在内存的起始地址}+W_{逻辑地址A在业内的偏移量}
$$

习题

![image-20240612155759558](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121558269.png)

为了方便计算机计算，通常页面大小刚好是**2的整数幂**，例如2^12B=4KB。在32位计算机中，后12位表示页内偏移W，而前面20位表示页号。这样计算机就不需要做过多的运算。

![image-20240612160457151](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121604894.png)

流程：进程需要逻辑地址A的物理地址时

1. 首先根据逻辑地址所在的页号来查询页表获取物理页号
2. 物理页号乘以页帧大小 + 虚拟地址业内偏移  = 物理地址

###### 基本地址变换机构

是一组硬件机构，用于实现逻辑地址转化为物理地址。

通常会在系统中设置一个页表寄存器（PTR），存放**页表在内存中的起始地址F**和**页表长度M**。

每个进程的页表信息都会被存放在PCB中，在进程被调度时，操作系统内核会把他们放在页表寄存器中。

流程：

操作系统进行调度时，恢复进程的PCB到处理器所对应的寄存器中。此时，页表寄存器会读取到该进程的**页表的起始地址F**（第0页的起始地址）和**页表长度M**（即该进程有多少页）

PC寄存器也会指向下一个指令的逻辑地址A

![image-20240612162546168](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121625764.png)

当操作系统查看PC寄存器后，可以很快速的将页号P和页内偏移W拆分。

![image-20240612162900422](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121629887.png)

拆分后，需要对页号P进行检查，即将页号P和页表长度（进程页数）进行对比，如果超过或者等于长度M，则意味着页号不合法。抛出越界中断。

如果合法，从页表寄存器提取出页表起始地址F和页号P相加得到内存块号

![image-20240612163449239](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121634557.png)

获得内存块号后，与逻辑地址内的页内偏移W组成物理地址，即可对内存访问。

![image-20240612163616540](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121636994.png)

例题

![image-20240612165959463](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121700387.png)

##### 具有快表的地址变换机构

###### 快表

**快表**（TLB）translation lookaside buffer,又称**联想寄存器**。是一种**访问速度比内存快很多的高速缓存**，用来存放**最近访问的页表项的副本**，可以加速地址变换的速度。于此对应，**内存中的页表称为慢表**

流程：

在CPU发送进程调度后，清空快表TLB。

![image-20240612173447123](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121734699.png)

此时，CPU在对页号合法性检测时，会先查看快表内的元素，如果命中，则直接将内存块号与页内偏移地址组合获得物理地址。否则如同之前一样，访问内存内的页表（慢表），获取页号所对应的内存块号，再和页内偏移组合形成物理地址。

![image-20240612173726894](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121737495.png)

若通过页表获取内存块号后，CPU会在快表内记录刚刚从内存中获取的内存块号，和与之对应的页号进行映射，存入快表。

![image-20240612174003312](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121740960.png)

在后续的执行中，若CPU没有发生进程调度，且命中快表，则加速了对该逻辑地址的转化，来访问内存。

由于快表的容量很小，在快表被填满后需要根据一些置换算法来进行替换。

快表和慢表同时查找和分别查找

![image-20240612175023409](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121750935.png)

假设查询快表需要1us, 查询慢表（访问内存）需要100us。快表的命中率为90%。则期望为：

- 分别查找（先快后慢）

$$
(1\mu s_{快表查询} + 100 \mu s_{访问内存})\times 0.9 + (1\mu s_{查询快表} + 100\mu s_{查询慢表} + 100\mu s_{访问内存})\times 0.1 = 111 \mu s
$$

- 同时查找

$$
(1\mu s_{快表查询} + 100 \mu s_{访问内存})\times 0.9 + ( 100\mu s_{查询慢表} + 100\mu s_{访问内存})\times 0.1 = 110.9 \mu s
$$

###### 局部性原理

- **时间局部性**：在一条指令被执行后，一段时间后再次被执行。

  例：在一个循环内，i++指令被重复执行

- **空间局部性**：连续访问一个连续的内存空间。

  例：在一个for循环内，连续访问一个数组

引入快表和未引入快表的区别：

- 在未引入快表时，访问一个逻辑地址需要访问两次内存
- 引入快表后，在命中快表时可以只访问一次内存
- 引入快表后需要对快表进行一次查询，且在命中后将内存块号和页号保存到快表中

###### 两级页表

用于解决单极页表存在的缺陷。

**单级页表的缺陷**：

- **页表开销过于庞大**

假设某计算机按字节寻址，支持32位逻辑地址，采用分页存储管理，页面大小为4KB，块号长度为4Byte。

页内寻址需要12bit来偏移寻址。所以剩下32-12=20bit来用于指明内存块号。即最多可拥有1M的页数。当所有内存块被分配时，则页表需要
$$
1M \times 4Byte = 2^{20} \times 2^{2}B = 2^{22}B
$$
来对应内存内的所有内存块号。

由于一个页的大小为4Byte，所以需要以下页帧来存储：
$$
2^{22} \div 2^{12} = 2^{10}页
$$
即1K页来表示，这意味着需要分配1K页的**连续空间**给**页表**。这个**开销过于庞大**，已经丧失了离散存储管理的优势。

- **局部性原理**

由局部性原理可知，有时候进程执行不需要知道整个进程的所有页号，**进程只需要访问几个页面即可正常运行**，因此没有必要将整个页表都常驻在内存中。

解决思路：我们可以将进程的页进行分组，使得每个内存块刚好可以放入一个分组。

例：页面大小4K，块号长度4B；则每页可以存放1K的块号。因此每1K个连续的页为一组，每组刚好占一个内存块。

获得分组后，为了使得分组能够连续，需要再次建立一张页表，即称为**页目录表**（外层页表、顶层页表）。

![image-20240612184452887](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121844896.png)

将原本的大页表分成多个小页表，即为**二级页表**，二级页表离散分布在内存中，二级页表由页目录表来管理。

![image-20240612184808529](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121848945.png)

如图所示，0#页表被存放在3号内存块中。

此时，虚拟地址的编址也需要发生变化。

![image-20240612185336303](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121853903.png)

自此，解决了页表需要连续存放在内存的问题。

其二，根据局部性原理，不需要将整个页表放入内存，将会采用**虚拟内存技术**，将页表的大部分**存放在磁盘**上。

实现：在页表的每一个页表项添加一个**标识位**，用于**记录是否被调入内存**中。

![image-20240613093128933](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406130931612.png)

当进程需要访问的虚拟地址不在内存中时，操作系统会产生一个**却页中断**，然后**将目标页面从外存调入内存**。

多级页表缺点：访问一个虚拟地址时，没有快表的情况下需要访存次数为
$$
n_{页表级数} + 1_{虚拟地址对应的物理地址}
$$

##### 基本分段存储管理

分段：进程的地址空间会按照**自身的逻辑**关系**划分为若干个段**，每个段都有一个段名，每段从**0开始编址**。

![image-20240613095057495](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406130950126.png)

操纵系统是以**段为单位分配**，在为每个段分配空间时，**每个段在内存中必须占据连续的地址空间**，但各个**段之间可以不相邻**。

有了段名，程序员可以更方便的进行编程。在对代码进行编译时，编译器会为每个段名替换一个段号。

此时，逻辑地址也需要发生改变。

![image-20240613095656578](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406130956122.png)

值得注意的是，**段号的位数**决定了每个**进程最多可以分几个段**，**段内地址**位数决定了**每个段的最大长度**是多少。

例：根据图中所示
$$
16_{31至16段号} \rightarrow 2^{16} = 64K个段
$$
每个段的长度（大小）为：
$$
16_{15至0段内地址} \rightarrow 2^{16} = 64KByte
$$
![image-20240613100621064](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131006607.png)

在编译时，段内的单元即为段内地址，段名转化为段号。

###### 段表

和分页机制相同，操作系统需要为每个进程建立一张段表，段表项一一映射各段的基址和段号，且保存了段长（大小）。

![image-20240613101123197](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131011853.png)

可以发现，与段表相比，多出了段长这个元素。其原因是页管理机制中，**页的大小相同**，但**段的长度并不相同**。

段表大小

假设计算机系统为32位虚拟地址寻址，其中前16位为段号，后16位为段长，内存大小为4GB。

则每个段的最大空间为
$$
2^{16}Byte = 64KByte
$$
内存寻址需要的最小位数：
$$
4GB = 2^{32} \rightarrow 32位
$$
所以，每个段表的表项大小为
$$
16_{段号位数} + 32_{内存寻址的最小位数} = 48位 \rightarrow 6Byte
$$
和页表一样，段号不占空间，其公式为：
$$
M_{段表起始地址} + K_{项段号} \times 6_{表项大小} = 段表项地址
$$


虚拟地址和物理地址转化过程：

首先，在CPU进行调度时，从进程的PCB中恢复寄存器信息，这个过程会将恢复段表寄存器。

![image-20240613103439530](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131034106.png)

此时，CPU得知该进程的段表在物理内存中的位置

![image-20240613103616119](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131036482.png)

恢复后，CPU读取PC寄存器中的下一条指令，即虚拟地址。该虚拟地址包含了段号和段内地址，CPU会对其段号与段表长度进行对比

![image-20240613103813533](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131038988.png)

当段号大于等于段表长度，CPU发出越界中断，否则继续执行。

随后，根据**段表始址**，在**内存中找到段表**。根据段表项寻址公式，找到所需的段表项在内存中的位置

从段表项中提取**段长**和虚拟地址中的**段内地址**进行对比，若内地址**大于等于段长**，意味着已经**超出该段的范围**，发出中断

![image-20240613110416006](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131104561.png)

然后**提取出该段号所对应的基址**，与虚拟地址中的**段内地址相加**得到物理地址

![image-20240613110521641](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131105031.png)

由于段的大小不等，与分页管理机制相比，多出了对段内偏移和段长的比较。

###### 分页分段的区别

页是信息的物理单位，其目的为实现离散分配，提高内存利用率，分页是一种系统行为，对用户不透明

段是信息的逻辑单位，分段的目的是为用户提供更好的编程需求，分段是对用户可见的（每个段都是由用户编写）。

分段比分页更容易实现代码共享保护

例：若两个进程共享一段代码，则只需要在表项内的段基址指向同一个地址即可

![image-20240613111709657](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131117245.png)

注意：共享代码一般为纯代码，不属于临界资源，进程之间不会修改同一个变量等，防止出现数据不一致。

**为什么页式管理不能做到代码共享？**

因为在页式管理中，代码是按照页的大小等量划分，一个页面中可能存在多个模块的代码。因此，无法决定共享代码的基址。

![image-20240613112236693](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131122154.png)

访存次数：

- 分页，取决于级数，一级一次，两级两次
- 分段：两次，第一次访问段表，第二次内存单元

分段机制也可以引入快表机构，将近期访问的段表保存着快表中，后续若命中快表则不需要访问内存查询段表，直接访问内存单元。

##### 段页式管理

分段+分页结合的一种管理方式

###### 分页分段优缺点分析

优点：

- 分页：内存空间利用率极高，存在少量的内部碎片
- 分段：很容易按照模块进行分段

缺点：

- 分页：不便于按照逻辑模块实现代码共享

- 分段：如果段过长，其需要很大的连续空间；且段式管理会产生外部碎片，需要通过紧凑技术压缩外部碎片形成较大空闲分区

  ![image-20240613113712878](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131137640.png)

###### 段页式

在进程按照逻辑模块分段以后，每个模块再按照页来划分。

![image-20240613113937459](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131139079.png)

内存中，还是以页为单位的内存块进行划分

![image-20240613114040483](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131140896.png)

###### 逻辑地址结构

此时，逻辑地址结构也需要发生改变

![image-20240613114133359](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131141776.png)

由此可见，段内地址被划分为页号和页内偏移地址。

**段号位数**：决定了每个进程最多可以分成几个段

**页号位数**：决定了每个段最大页数

**页内偏移位数**：决定了页面大小

例：在一个32位寻址系统中，按字节（Byte）编址,段号位数为16位，页号为4位，页内偏移为12位，则

最大段数：
$$
2^{16} \rightarrow 64K个段
$$
每个段的最大页数：
$$
2^{4} \rightarrow 16页
$$
页的大小：
$$
2^{12} \rightarrow 4KByte
$$
分段式对用户可见的，但段内分页是对用户不可见的。系统会根据内段地址自动划分页号和页内偏移。

###### 段表和页表结构

在段页式管理中，段表不再存储该段的基址，而是存储该段所对应的**页表基址**。而段表长度则改外**页表长度**。

![image-20240613115235610](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131152257.png)

此时，一个进程会对应一个段表，而一个段表会对应多个页表

![image-20240613115550987](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131155462.png)

###### 逻辑地址转物理地址流程

和之前一样，在CPU发生进程调度时，会设置段表寄存器。

设置完以后，将段号和段表长度进行对比，判断是否越界

![image-20240613115844083](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131158554.png)

然后根据段表始址查询段表，再根据段号，计算出对应的段表项。

由于各个模块的大小不同，所以每个模块的页数都不同，为了排除越界风险，需要将虚拟地址这种的页号与段表中的页表长度进行对比。

![image-20240613120525854](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131205347.png)

从段表项内提取出页表长度与页号进行对比，若不越界，提取出页表存放在物理内存的块号（即页表物理地址），再根据页表找到对应的页表项，计算出逻辑地址所需要的内存块地址，在根据页内偏移量，和内存块地址进行组合形成最终的物理地址。

![image-20240613120758616](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131207035.png)

根据最终的物理地址，访问内存单元。

在没有引入快表的情况下，需要对内存进行3次访存。引入快表后，快表可以记录最近访问的段号和页号，进行快速访存。

### 虚拟内存

#### 传统存储管理方式的特征和缺点

在传统存储管理方式中，事实上，根据局部性原理可知，在一个进程运行时并不需要在内存中存放大量的指令和信息。但传统的存储管理一次性将作业（进程）装入到内存中，会引发两个问题：

1. **一次性**：传统管理方式希望**一次性**将作业装入内存中，当作业非常庞大时，内存无法承载过大的作业。当大量作业异步运行时，内存无法容下所以的作业，只允许少量作业运行，导致**多道程序并发度下降**。
2. **驻留性**：一旦作业被装入内存时，则会一直驻留在内存中，直到停止\结束运行。但事实上，一个进程运行时，只需要一小部分的数据即可正常运行。这就导致其余的数据大量占据了内存的空间，浪费资源。

#### 虚拟内存的定义和特征

基于局部性原理，在程序装入内存时，只需**将必要的部分装入内存**，其余的部分存放在外存即可。

当程序运行时需要**访问不在内存内的信息**时，操作系统会负责将所需的信息**从外存调入内存**，程序方可继续执行。

当内存的空间不够时，操作系统会将**暂时用不到的信息换出到外存**，为需要的信息腾出空间。

在操作系统的管理下，用户们会认为自己有着较大的内存空间，即虚拟内存。

##### 虚拟内存的三个特征

- **多次性**：无需在作业运行时一次性装入内存，而是允许被分成多次调入内存。
- **对换性**：进程无需一直驻留在内存中，允许被换出到外存中，外存内的进程也可以被换进内存。
- **虚拟性**：从逻辑上扩充了内存的容量，但实际上内存的大小不变。

#### 虚拟内存的实现

通常，虚拟内存的实现是建立在**离散分配的内存管理**。

**为什么不能基于连续分配方式呢？**

因为当作业的大小有**很大差异**时，连续的内存空间需要多内存**进行紧凑**技术来腾出空间，极大的**浪费资源**。

和传统的离散管理方式，操作系统需要负责从外存将进程/信息换进内存中。因此，操作系统需要提供**请求调页（请求调段）**的功能

在内存空间不足时，操作系统需要提供**页面置换（段置换）**功能

实现方式：

- 请求分页存储管理
- 请求分段存储管理
- 请求段页存储管理

##### 请求分页管理

- 页表机制
- 却页中断机构
- 地址变换机构

与基本分页管理相比，请求分页管理为了实现**请求调页**，操作系统需要知道**每个页面是否调入内存**，如果没有调入，那么操作系统需要知道**页面在外存被存放的位置**。

当**内存空间不够时**，请求分页管理为了实现**页面置换**，操作系统需要通过某种算法来**决定哪个页面应该被换出**，从**页面的修改信息**角度出发，当一个页面尚未被修改时，那么从外存调入的数据可以直接覆盖。因此**操作系统需要记录各个页面的修改信息**。

###### 请求页表

因此，请求分页管理的页表中，添加了新的信息：

![image-20240613142135272](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131421135.png)

**状态位**：表明该页是否在内存中，当状态位为0时，表示不在内存中

**访问字段**：可以是记录最近被**访问过的次数**，或记录**上次访问的时间**。操作系统可以基于访问的**频率**或**访问的时间**来决定是否**换出该页面**

**修改位**：页面**是否被修改**。没有被修改过的页面**不需要写回外存**，可直接覆盖，节省写回外存的时间；相反，若被修改过，则需要**写回外存**。

**外存地址**：页面在外存被**存放的位置**

###### 却页中断机构

当我们访问的页面不在内存时，便会产生一个却页中断，由操作系统的**却页中断处理程序**来处理该中断。

![image-20240613143353222](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131433981.png)

此时，**缺页的进程进入阻塞状态**，被操作系统放入阻塞队列。在**调页完成**后再将其唤醒，放入**就绪队列**中。

操作系统根据**外存地址**进行IO操作，将**缺失页面放在内存**的空闲块中

![image-20240613143851983](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131438480.png)

且修改表项对应的内容

![image-20240613144010430](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131440035.png)

若内存中**没有空闲块**，则操作系统需要通过**页面置换算法**来**淘汰**一个页面，若该页面**被修改过**，则需要**写回外存**；否则，**直接覆盖**。

###### 逻辑地址转化物理地址

和传统页式管理类似，多出了几个新的步骤：

1. **判断**需要访问的页是否在内存中
2. 在新的页面调入时，内存没有更多空闲空间，则需要**请求一次页面置换**
3. 每当一个页面被访问或被换入换出，都需要**对表项进行修改**

流程：

1. 检查页号是否越界

   ![image-20240613145350581](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131453305.png)

2. 查看快表是否命中，若命中，直接访问物理地址

   ![image-20240613145729976](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131457616.png)

3. 若没有命中，查看慢表，通过状态位判断是否在内存中。若不存在，则由操作系统的中断处理程序来处理缺页中断。**此时注意**！若**快表内页面被置换**，需要**清楚被换出的页面的表项**，否则可能会**访问错误的页面**！！！

4. 若没有命中，查看慢表，再通过页内偏移组合访问物理内存单元，并将访问的页面记录在快表和慢表中

   ![image-20240613150010974](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131500786.png)

细节补充；

1. 只有“写指令”才需要修改“修改位”。
2. 一般来说，对表项的修改一般在快表内进行。在删除快表内的某一个表项时（即某页从内存中被换出），才会将被删除表项复制的慢表中，这样减少了访存次数。

##### 页面置换算法

在**内存不够**时，操作系统**通过页面置换算法**，**选择一个用不到的页面信息换出到外存**。

页面置换需要通过**I/O操作**进行，所以，页面置换的**开销相对而言比较大**，因此，页面算法应该**追求更少的缺页率**（即尽可能少的换入换出）。

- 最佳置换算法（OPT）
- 先进先出置换算法（FIFO）
- 最近最久未使用置换算法（LRU）
- 时钟置换算法（CLOCK）
- 改进的时钟置换算法

###### 最佳置换算法（OPT）

最佳置换算法（OPT，optimal），每次选择**永不再用**或在**最长时间内不再被访问的页面**进行淘汰，保证最低的缺页率。

例：

![image-20240613152919569](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131529254.png)

在置换页面时，观察访问页面的序列，将最后一个出现的页面进行置换。

如图所示，在箭头指向的这个时刻，0和1页面相继出现过，所以选择7号页面进行淘汰

值得注意的是，缺页中断的次数并不等于页面置换次数。在一个页面调入内存时，如果有空闲块则无需进行页面置换。

###### 缺页率公式

$$
缺页率 = \frac {缺页中断次数}{访问页面的次数}
$$

在该题中，缺页率：
$$
\frac {9}{20} = 45\%
$$
最佳置换算法只是一种**理想算法**，实际上我们**无法得知访问页面的次序**，因此最佳置换算法时**无法实现**的。

###### 先进先出置换算法（FIFO）

每次选择淘汰的页面是**最早进入内存的页面**。

实现方法：通过一个**队列**（先进先出），根据**时间线**将进入内存的页面放进队列中，每当出现一次**缺页置换**时，**移除队列的第一个元素**（即最早进入队列的页面）。**队列的大小取决于系统分配给进程的内存块数**。

例：

![image-20240613160513869](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131605606.png)

如图所示，该进程被分配了3个内存块，在执行的过程中，产生了9次缺页。

我们将题目进行修改，为进程分配4个内存块

![image-20240613160925603](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131609140.png)

我们会发现，增加了一个内存块分配，产生了10次缺页。惊奇的发现增加内存块的分配反而增加了缺页次数。

###### Belady异常

当为进程分配的物理块数增大时，会产生缺页次数不减反增的异常现象。

事实上，只有FIFO算法会产生Belady异常。

该算法实现简单，但与进程实际的运行规律不同，因为**先进入**的页面有**可能是经常被访问**的页面。因此该算法的**性能较差**。

###### 最近最久未使用置换算法（LRU）

最近最久未使用置换算法（LRU，least recently used），每次淘汰的页面是最近最久未使用的页面。

实现方法：

此时页表的表项内的访问字段记录页面被访问的时间t，当需要淘汰一个页面时，只需将
$$
max(当前时间 - t_{表项i}) = i
$$
i即为需要被置换的页面。

例：

![image-20240613162400541](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131624351.png)

在箭头指向的这个时刻，7号页距离当前时间最久远的表项，因此新页面3将会替换7号页面

实际中，最近最久未使用置换算法需要**专门的硬件支持**，虽然算法**性能好**，但是**实现困难**，**开销较大**。

###### 时钟置换算法（CLOCK）

又称为最近未用算法NRU（not recently used），是一种性能和开销比较均衡的算法。

次算法分为两种形式，简单的和较复杂的

**简单的CLOCK算法**：

在页表中引入访问位，1表示最近被访问过，0则最近没有被访问过。将内存中的页面都通过指针链接成一个循环队列。当某页被访问时，其访问位置成1。

当需要淘汰一个页面时，对该循环队列进行遍历，若访问位为1，则将它置为0，如果为0，则置换。

在极端的情况下，访问队列全部为1，则会进行两次遍历：第一次将所有的访问位置为0，第二次将第一个遇见的0置换出去。

例：

![image-20240613164010205](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131640906.png)

依次将1，3，4，2，5链接成一个单向循环队列

![image-20240613164021610](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131640226.png)

在来到指针指向的这个时刻时，对单向循环列表中的所有访问位依次置为0，指针回到原先指向的位置

![image-20240613164325876](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131643999.png)

随后，将首个访问位为0的页面置换出去，例中为1号页面，然后指针指向下一个页面。

![image-20240613164509571](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131645197.png)

在后续的执行中，指针的位置保持不变，只需要将近期访问过的页面的访问位进行修改即可。一旦一个访问的页面需要被换入内存时，指针开始扫描。将1置为0，将0置换出去。以此类推。

![image-20240613164928346](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131649134.png)

回到例中，指针从3号页开始旋转，分别将3，4号页置为0 。来到2号页，发现2号页的访问位为0，于是换出2号页，将7号页换入并将访问位置为1，指针指向下一页（5号页）。

**改进的时钟置换算法**：

**简单版本**只考虑了该**页面最近是否被访问过**。

事实上，如果被淘汰的页面**没有被修改过**，则**不需要执行I/O操作进行回写外存**。只有**被修改**过且**被淘汰**的页面才需要**写回外存**。

因此，在页表内引入修改为，0为页面未修改，1为页面被修改。

访问位和修改为组成一个二维向量
$$
(访问位,修改位)
$$
（1，1）则表示该页面近期被访问过且被修改过。

**算法改进**：

将所有可能被置换的页面排成一个循环队列，开始第一轮扫描。

**第一轮**：从当前位置开始扫描，扫到第一个（0，0）的页进行置换，本轮扫描**不修改任何标识位**。

**第二轮**：若第一轮扫描失败（即没有找到0，0的页），尝试找到（0，1）的页置换，**本轮扫描将所有扫描过的访问位置为0**。

**第三轮**：若第二轮扫描失败（即没有找到0，1的页），尝试找到（0，0）的页进行置换，**本轮扫描将不会修改任何标志位**。

**第四轮**：若第三轮扫描失败（即没有找到0，0的页），找到第一个（0，1）的页用于置换。**此轮一定会找到一个（0，1）的页**，因为第二轮已经将所有的访问位置为0。

改进后的算法选择一个淘汰页面最多会进行**4次扫描**。

扫描轮次解读：

事实上，是按照置换的优先级进行扫描，优先级较高的先被淘汰

第一轮优先级：最近没访问，且没修改的页面 （0，0）

第二轮优先级：最近没访问，但修改过的页面 （0，1）

第三轮优先级：最近访问过，但没修改的页面 （1，0）

第四轮优先级：最近访问过，且修改过的页面 （1，1）

能进入第四轮扫描说明每个页面在近期都被访问过且修改过。

#### 页面分配策略

##### 驻留集

指的是请求分页存储管理中给进程分配的物理块集合。

在支持虚拟存储技术的系统中，**驻留集的大小**一般**小于进程的总大小**。

若驻留集太小，进程过大，则会频繁产生缺页中断，系统需要花费大量时间处理中断；若驻留集太大，则占据了太多的内存空间，导致资源浪费。

因此，选择一个合适的驻留集是非常重要的，提出了两种策略：

1. **固定分配**：操作系统会为每个进程分配一组固定数目的内存块，在进程运行期间不再改变，即**驻留集大小不变**。
2. **可变分配**：操作系统先为每个进程分配一定数目的内存块，在进程运行期间，可根据当前情况，适当的增加或减少驻留集，即**驻留集大小可变**。

对置换也提出两种策略：

1. **局部置换**：发生缺页时，只能选进程自身的内存块进行置换
2. **全局置换**：可以将操作系统保留的空闲内存块分配给缺页进程，也可以将别的进程持有的内存块换出到外存，再分配给缺页进程。

我们可以对这些策略进行组合

![image-20240613173158690](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131731378.png)

我们发现，固定分配无法和全局置换进行组合，会导致自己不再是固定分配，转变为可变分配。

###### 固定分配局部置换

系统为各个进程分配一定数量的内存块，在运行期间驻留集大小不变。若进程发生缺页，只能够置换自己的内存块。

缺点：**很难确定**为每个进程分配的**内存块数量**。采用这种策略的系统通常需要结合进程大小，优先级，等等参数来确定内存块分配数量，灵活性较差。

###### 可变分配全局置换

系统为各个进程分配一定数量的物理块，操作系统会保持一个空闲内存块队列。当某个进程发生缺页时，从空闲内存块队列中分配一个内存块给进程；若空闲块的数量为0时，系统会选择**未被锁定的页面**换出外存，再将其分配给缺页进程。

**什么是未被锁定的页面？**

操作系统会标记一些非常重要的页面，这些页面不会从内存中被换出，即为锁定页面。其未锁定指的是，对于操作系统来说，是一些可有可无，非必要的页面，他们允许被换出内存。

采用这种策略的系统，一旦进程发生缺页，就会**获得一个新的内存块**。当**内存空闲块用完**时，操作系统会选择一个未锁定的页面进行置换，**被置换的页面可能是别的进程的页面**，其进程可能会产生**缺页**，**增加了缺页率**。

###### 可变分配局部置换

操作系统会为每个进程分配一定数量的内存块，当某个**进程发生缺页**时，只允许**从自己的内存块中置换页面**。如果该进程**频繁的产生缺页**时，操作系统**会适当分配给他更多的物理块**，直至缺页率**趋于一个适当的程度**；反之，若某个进程的**缺页率非常低**，操作系统就会适当的**减少它的内存块数**。

##### 调入页面策略

在什么时候调入所需要的页面呢？提出两种策略。

1. 预调页策略：根据局部性原理（空间局部性），一次调入若干个相邻的页面，相比于一次调入一页效率更高。但如果调入的页面大多数没有被访问，反而降低了效率。因此，该策略预测不久过后可能被访问的页面，将他们预先调入内存中，减少对外存进行I/O操作。但目前的预测成功率只有50%左右。故这种策略**主要用于进程的首次调入，即运行前调入**，通常有程序员指出。例如：先将main函数所对应的页调入内存中。
2. 请求调页策略：**进程在运行期间发现缺页时才将所缺页面调入内存**。由这种策略调入的页面一定会被访问，但一次仅限于一页，这意味着每次调页都需要和磁盘进行I/O操作，因此开销较大。

##### 调入内存过程

外存（磁盘）通常分为：

- 对换区（采用连续分配方式，读/写速度更快）
- 文件区（采用离散分配方式，读/写速度更慢）

1. 当系统拥有足够的对换空间，页面的换入换出都是在内存和对换区进行，保证换入换出速度。在进程运行之前，需要将进程的相关数据从文件区复制到对换区，然后对换区和内存再进行换入换出操作。

![image-20240613182336402](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131823433.png)

2. 若系统没有足够的对换空间，凡是不会被修改的数据则会直接从文件区调入，由于这些数据不会被修改，因此换出时不必再写回外存，在需要时直接从文件区读取。对于可能被修改的数据，仍然通过对换区进行换入换出操作。

![image-20240613182725035](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131827023.png)

3. UNIX方式：第一次被调入的页面直接从文件区调入，在进程需要置换页面时，页面被调出到对换区，之后若还需要该页面则直接从对换区调入。

![image-20240613183022025](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131830611.png)

##### 抖动（颠簸）现象

刚刚换入\换出内存的页面，马上又被换出\换入外存。其原因为进程频繁访问的页数高于系统分配给进程的驻留集，即系统分配给进程的内存块不够多。

系统会花费大量时间处理缺页中断，因此我们要避免这种现象发生。

###### 工作集

为了解决抖动（颠簸）现象，提出了工作集的概念。

指的是某段时间间隔里，进程实际访问页面的集合。

操作系统会根据窗口尺寸来算出工作集。

例：假设一个进程对页面的访问序列如下，窗口尺寸为4，指针指向的时刻的工作集为当前的页面向前数窗口尺寸个页面，即为当前的工作集

![image-20240613184718085](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131847762.png)

可以发现，工作集的大小有时小于窗口尺寸。

在实际应用中，操作系统会统计工作集大小，根据工作集大小给进程分配若干个内存块。

例如：一个进程的窗口尺寸为5，经过一段时间的检测发现该进程的工作集最大为3，说明该进程有很好的局部性，为该进程分配3个以上的内存块即可满足进程运行需求。

一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将会产生频繁的缺页，抖动现象。

#### 内存映射文件

内存映射文件（Memory-Mapped Files)

是操作系统向上层程序员提供的功能（系统调用）

- 方便程序员访问文件数据
- 方便多个进程共享同一个文件

在传统的文件访问方式中，访问文件流程：

1. open系统调用，打开文件
2. seek系统调用，将读写指针指向某个偏移位
3. read系统调用，从读写指针指向的地址开始，读取若干个数据（从磁盘写入内存）
4. write系统调用，将内存中的指定数据写回磁盘（根据读写指针确定要回写到什么位置）
5. close系统调用，关闭文件

![image-20240613190726620](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131907495.png)

内存映射文件方式流程：

1. open系统调用，打开文件
2. mmap系统调用，将文件映射到进程的虚拟地址中，返回一个映射虚拟地址的起始位置的指针。

此时，文件并没有真正的被读取到内存中，只是将文件内容的虚拟地址映射到内存中，在程序员需要进行读写时，才会从系统中调入内存。程序员不需要通过seek, read, write来偏移\读取\写入数据。由操作系统自主完成。程序员只需要通过mmap返回的指针进行偏移操作即可。

在程序关闭时，操作系统会自动将修改的部分写回磁盘。

![image-20240613191413373](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131914317.png)

文件共享的实现：

多个进程的虚拟地址空间内会对需要被共享的文件进行地址映射，一旦共享的文件被修改（物理内存的数据被修改），由于是映射关系，其余的进程能够立马感知的数据被修改，实现文件共享。

![image-20240613191853122](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131918981.png)

# 文件管理

## 文件基本概念

计算机中存放了各种各样的文件。

- 那么，文件都有哪些属性呢？
- 文件内部的数据应该怎样组织起来呢？
- 文件之间又应该怎么组织呢？
- 从操作系统的角度考虑，如何才能方便用户、应用程序使用文件呢？
- 文件数据应该怎么存放在外存呢？

### **文件的属性**

- **文件名**，同一个目录下不允许存在相同文件名的文件
- **标识符**，文件名并不能唯一标识文件，操作系统会为每一个文件生成一个唯一标识符，此标识符对用户来说毫无可读性。
- **文件类型**，操作系统可以通过文件类型为他们设置一个默认软件来打开文件
- **文件的位置**，文件的存放路径
- 文件的大小、创建时间
- 文件的保护信息，操作系统会将用户分组，每个分组对文件的访问权限可能不同

### 文件结构

- **无结构文件**（流式文件）：如文本文件，二进制文件等无结构文件。
- **有结构文件**：例如数据库，由一条一条的记录组成，每个记录都是由数据项组成。数据项是文件系统中最基本的数据单位。

### 文件之间的组织

- 根目录：盘符，D盘，C盘等
- 文件夹（是一种特殊的有结构文件），在根目录下，可以创建一层一层的目录来存放文件

### 操作系统为上层提供的基本功能

- **创建文件**，通过create系统调用创建
- **读文件**，将文件数据读入内存，才能让CPU处理。双击文件后，操作系统通过调用read系统调用，将文件数据从外存读入内存，并显示在屏幕上
- **写文件**，在我们按下保存按钮后，操作系统会调用write系统调用，将修改后的文件数据从内存写回外存
- **删除文件**，操作系统通过调用delete系统调用从外存删除文件
- **打开文件**，系统调用open，在读写文件之前，需要打开文件
- **关闭文件**，系统调用close，在读写结束后调用

较复杂的功能可以通过以上的基本功能组合而成，例如复制文件，先创建一个新的文件，再把源文件写入内存，再将内存中的数据写入新的文件。

### 文件外存存放

和内存相同，外存也是由一个个的存储单元组成，每个存储单元可以存储一定量的数据，例如1Byte。每个存储单元都对应着一个物理地址。

外存也会被分为一个个磁盘块\外存块，每个磁盘块的大小是相等的。

文件的逻辑地址也可分成逻辑块号，块内地址。同样的，操作系统也需要将文件的逻辑地址转换为物理地址。块内地址的位数取决于磁盘的大小。

操作系统以块来分配存储空间，因此即使一个文件的大小远小于存储空间的大小，也会占据一个外存块。

外存的读入内存时，同样以外存块为单位。

### 操作系统实现的其他文件管理功能

- 文件共享：多个用户可以共享一个文件
- 文件保护：保证不同的用户对文件有不同的操作权限

## 文件的逻辑结构

文件的**逻辑结构**指的是，在**用户**看来，文件内部的数据应该时如何组织起来的

文件的**物理结构**指的是，在**操作系统**看来，文件的数据是如何存放在外存的

- 无结构文件
- 有结构文件

文件操作的具体实现与逻辑结构、物理结构都有关。
