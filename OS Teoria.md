# 内存

## 内存基本知识

存放数据，程序在执行前需要先放到内存中才能被CPU处理执行，缓和CPU与硬盘之间的速度问题。

### 内存地址表示

一个4GB的内存等于
$$
4GB = 2^{30} \times 2^2 = 2^{32}
$$
需要32位bit来指向内存中的所有地址。

### 虚拟地址和物理地址

物理地址：内存的真实地址

虚拟地址（逻辑地址）：一个程序通常把整个内存看作是自己的，即该程序的第一条指令从逻辑地址0开始。但实际上它的物理地址可能在任意位置。需要通过不同的策略来转化逻辑地址和物理地址。

### 三种策略

三种装入内存的策略

- 绝对装入
- 可重定位装入（静态重定位）
- 动态运行时装入（动态重定位）

#### 绝对装入

在编译时，如果知道程序将放在内存中的哪个位置，编译程序将会为目标代码产生**绝对地址**。在加载程序时，根据绝对地址将代码写入内存中。

该策略只适用于**单道程序环境**。灵活性差，固定的绝对地址对机器的适配性很差。很难实现在多台计算机上执行。

#### 静态重定位（可重定位装入）

在编译程序时，为程序提供从0地址开始的逻辑连续地址。在装入内存时，可根据内存的当前情况，为逻辑地址添加一个偏移量，即为内存中物理地址。
$$
逻辑地址 \space+\space 偏移量_{OFFSET} \space=\space 物理地址
$$
此策略提高的程序的灵活性，可在多台计算机上运行。缺点是需要在内存中，一次性加载所有指令（代码），如果内存没有足够的空间，就无法运行此程序。

#### 动态重定位（动态运行时装入）

和静态重定位类似，程序以逻辑地位0开始，在程序加载到内存的过程中，存在一个**重定位寄存器**，它将记录**程序在内存中的起始位置**，在后续的加载中，只需要将逻辑地址和重定位寄存器内的值进行相加，生成新的物理地址。
$$
逻辑地址 \space+\space 重定位寄存器的值_{OFFSET} \space=\space 物理地址
$$
这使得程序可以在不连续的内存空间中运行，每次执行一个指令时，只需要将指令的逻辑地址与寄存器内的值相加获得新的物理地址。同时，程序所需加载到内存中的大小可以超过真实的物理内存大小。

## 从写程序到程序允许

1. 程序员通过各种文本编辑器写出**源代码**
2. 编译器将各个源代码转化为各个**模块**，每个目标模块都是从**0开始的逻辑地址**，相互独立，
3. 通过链接，将各个目标模块组装起来，形成一个模块，即为**可执行文件**。可执行文件拥有一个**完整的逻辑地址**。组装时，也会导入各个模块所引用的库函数，例如:stdio.h。
4. 根据不同的策略将程序装入内存，生成物理地址。

![image-20240608111126777](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158212.png)

### 三种链接方式

#### 静态链接

在程序运行之前，先将各个目标模块及他们所需的库函数链接成一个完整的可执行文件，装入模块。装入后不可拆分。

![image-20240608111438924](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158468.png)

#### 装入时动态链接

在各个模块加载的内存中时，才会链接模块所需要的库函数。其物理地址是一边装入一边形成的。

![image-20240608111610170](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158710.png)

#### 运行时动态链接

在程序执行时，只将必要运行的模块加载到内存中，加载时，对其模块进行链接。但如果一个模块没有被执行，即没有被加载到内存时，该模块不会被链接且不被加载到内存中。

![image-20240608111855121](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158324.png)

## 内存管理

- 操作系统负责内存空间的分配和回收

- 虚拟内存的使用和管理，对内存空间进行扩充

- 地址转换，程序员负责编写指令，数据的逻辑地址。转换为物理地址由操作系统负责，即上述中的三种装入方式。
- 内存保护，操作系统需要保证各个进程在各自的存储空间内运行，互不干扰。

### 内存保护

#### 1.上下限寄存器

在CPU中设置一对上、下限寄存器，存放进程的起始地址和结尾地址，进程指令要访问某一个地址时，CPU会检查该指令是否越界。

#### 2.重定位寄存器和界地址寄存器

重定位寄存器存放进程的**起始地址**，界地址寄存器（限长寄存器）存放进程的**最大逻辑地址**。

CPU执行过程：

1. 当进程想要访问一个逻辑地址时，该逻辑地址会先和界地址寄存器进行对比，如果没越界，则合法；如果越界，则抛出异常。
2. 合法的逻辑地址会和重定位寄存器的起始地址相加，访问真实的物理地址。

![image-20240609112758055](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091128131.png)

### 内存空间的扩充

- 覆盖技术
- 交换技术
- 虚拟存储技术

#### 覆盖技术

覆盖技术解决了程序大小超过物理内存的问题。

覆盖技术思想：将程序分为多个段（模块），常用的段常驻在内存中，不常用的段在需要时调入内存。

内存中分成一个固定区，和若干个覆盖区。在**固定区**内的指令，一旦调入后则**不能被调出**（除非程序结束）；覆盖区则在需要时调入/调出内存。

![image-20240609113707118](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091137169.png)

覆盖技术必须由程序员声明覆盖结构，操作系统完成自动覆盖。

缺点：对用户不透明，增加了编程负担。

只有早期的操作系统采用这种技术，已经成为历史。

#### 交换（对换）技术

思想：在内存空间紧张时，系统将内存中某些进程暂时换出到外存（硬盘等），把外村中某些已具备运行条件的进程换入内存中

当进程被换出到外村时，内存会保留被换出的进程的PCB（Process Control Block），PCB中保留了被换出进程的必要信息，例如在磁盘的位置等。随后将这些PCB挂起队列，即中级调度（内存调度），决定哪个处于挂起状态的进程重新调入内存。

![image-20240609114718386](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091147431.png)

问题：

1. 应该在外存的什么位置保存被换出的进程？
2. 什么时候换出？
3. 应该换出那些进程？

答：

1. 在电脑的磁盘中，磁盘被分为两个区域：对换区和文件区。

   文件区：追求存储空间的利用率，对文件区采用的是**离散分配方式**

   对换区：只占磁盘空间的小部分。对换的速度直接影响系统的整体速度，因此对换区追求换入换出的速度，通常对换区采用**连续分配的方式**。

2. 交换通常在许多进程运行且内存吃紧时进行，直到系统负荷降低。例如：许多进程运行时频繁发生缺页，说明内存吃紧，此时可以换出一些进程，直到缺页率明显下降时，暂停换出。

3. 可优先换出阻塞进程，或换出优先级较低的进程。但为了避免优先级较低的进程发生**饥饿现象**，即调入内存后很快又被换出，通常还会考虑进程在内存的**驻留时间**。

PCB会常驻内存，不会被换出。

### 内存空间的分配与回收

#### 连续分配管理

- 单一连续分配
- 固定分区分配
- 动态分区分配

连续分配：系统为用户进程分配的必须是一个**连续的内存空间**

##### 单一连续分配

在单一连续分配中，内存被分为**系统区**和**用户区**。

系统区：通常位于内存的**低地址**部分，用于存放**操作系统的相关数据**；

用户区：用于存放用户进程的相关数据。在单一连续分配中，内存只允许存在**一道用户程序**，即用户程序独占整个用户空间。

优点：实现简单，**无外部碎片**。可以采用覆盖技术扩充内存，不一定需要内存保护。

缺点：只适合单用户单任务的操作系统，不支持多道程序并发运行。存在**内部碎片**，降低存储器的利用率。

![image-20240609150935730](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091509770.png)

- 内部碎片：操作系统为一个进程分配了一段内存空间 ，用户程序并没有使用全部被分配到的内存空间，存在一些空间没有被利用。
  $$
  内部碎片\space = \space 被分配的内存空间 \space - 实际使用的空间
  $$

- 外部碎片：内存中，分配给进程的空间并不是完全连续的，进程之间存在一些细小的空间，这些空间较小且无法分配给别的进程，即为外部碎片。

##### 固定分区分配

为了支持多道程序，内存中需要装入多到程序。于是将内存划分为若干个大小的分区，每个分区只允许装入一个程序。

分区可以是大小**相等**的分区，也可以是大小**固定但不同**的分区。

![image-20240609152551701](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091525744.png)

相等：**缺乏灵活性**，程序之间的大小可能并不相同。但这种设计适合于控制**多个相同程序**的场合。

分区大小不同：增加了灵活性。

在固定分区分配中，操作系统需要建立一个**分区说明表**，来实现各个分区的分配和回收。

![image-20240609153618464](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091536508.png)

当某用户程序要装入内存时，由操作系统内核根据用户程序大小检索该表，从中找到一个能满足大小的、未被分配的分区，分配给该程序，然后将状态修改为已分配。

优点：实现简单，无外部碎片。

缺点：

1. 当程序太大时，可能没有一个分区满足该进程的需求，此时不得不采用覆盖技术来解决，但覆盖技术需要付出一定的时间代价。
2. 当程序小于分区大小，由于程序独占一个分区，会产生内部碎片。

##### 动态分区分配

动态分区分配也称为可变分区分配。

在程序装入内存时，根据进程的大小动态建立分区，该分区的大小正好适合装入进程。

![image-20240609154704409](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091547457.png)

问题：

1. 系统需要用什么样的数据结构记录内存的使用情况？
2. 当多个空闲分区都满足装入需求时，该选择哪个分区进行分配呢？

![image-20240609154811643](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091548682.png)

3. 如何进行分区的分配和回收操作呢？

答：

1. 两种数据结构来记录内存使用情况：

   - 空闲分区表：每个空闲分区都对应一个表项，表项包括分区号、分区大小、分区起始地址等信息

     ![image-20240609155115389](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091551450.png)

   - 空闲分区链：通过链表的形式，每个链表结构含有两个指针，指针分别指向地址更低的空闲分区的结束地址和下一个分区的起始地址。除外在分区的起始部分还可以记录分区大小等分区信息。

     ![image-20240609155712906](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091557948.png)

2. 当一个进程在被装入时，存在多个分区满足此进程，需要通过**动态分区分配算法**，从空闲分区表/链 中，选择一个分区分配给该进程。

3. 分配时，通过不同的动态分区分配算法：

   - 决定分配一个**空间大于此进程的分区**时，在分区表内减去被分配的空间，其**分区的数量仍然保持不变**。

     ![image-20240609160454078](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091604155.png)

   - 分配一个空间大小等于某个分区空间时，在表项内删除此分区，分区数量减1.

     ![image-20240609160636476](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091606540.png)

   回收时，

   - 当回收的进程存在一个相邻的空闲分区，则将回收后的空间添加到相邻的分区，并合并为一个分区。

     ![image-20240609160901581](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091609210.png)

   - 当回收的进程存在两个相邻的空闲分区，则将这三个分区全部合并为一个分区。

     ![image-20240609161107269](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091611322.png)

   - 当回收的进程不存在一个相邻的空闲分区，则在分区表内添加一个新的表项。

     ![image-20240609161234363](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091612409.png)

   注意：分区表的排序不一定时按照地址的递增顺序排列，具体的排列方式根据不同的动态分区分配算法来决定。

   

外部碎片解决方案

通过紧凑技术（Compaction）：利用换入\换出技术，将进程进行上下平移，此时碎片空间都会被向外挤出，形成一个大的空闲分区。重定位寄存器，保存进程新的起始物理地址，完成紧凑技术。

换入换出：

![image-20240609162825915](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091628972.png)

![image-20240609162901321](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091629362.png)
