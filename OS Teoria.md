# 内存

## 内存基本知识

存放数据，程序在执行前需要先放到内存中才能被CPU处理执行，缓和CPU与硬盘之间的速度问题。

### 内存地址表示

一个4GB的内存等于
$$
4GB = 2^{30} \times 2^2 = 2^{32}
$$
需要32位bit来指向内存中的所有地址。

### 虚拟地址和物理地址

物理地址：内存的真实地址

虚拟地址（逻辑地址）：一个程序通常把整个内存看作是自己的，即该程序的第一条指令从逻辑地址0开始。但实际上它的物理地址可能在任意位置。需要通过不同的策略来转化逻辑地址和物理地址。

### 三种策略

三种装入内存的策略

- 绝对装入
- 可重定位装入（静态重定位）
- 动态运行时装入（动态重定位）

#### 绝对装入

在编译时，如果知道程序将放在内存中的哪个位置，编译程序将会为目标代码产生**绝对地址**。在加载程序时，根据绝对地址将代码写入内存中。

该策略只适用于**单道程序环境**。灵活性差，固定的绝对地址对机器的适配性很差。很难实现在多台计算机上执行。

#### 静态重定位（可重定位装入）

在编译程序时，为程序提供从0地址开始的逻辑连续地址。在装入内存时，可根据内存的当前情况，为逻辑地址添加一个偏移量，即为内存中物理地址。
$$
逻辑地址 \space+\space 偏移量_{OFFSET} \space=\space 物理地址
$$
此策略提高的程序的灵活性，可在多台计算机上运行。缺点是需要在内存中，一次性加载所有指令（代码），如果内存没有足够的空间，就无法运行此程序。

#### 动态重定位（动态运行时装入）

和静态重定位类似，程序以逻辑地位0开始，在程序加载到内存的过程中，存在一个**重定位寄存器**，它将记录**程序在内存中的起始位置**，在后续的加载中，只需要将逻辑地址和重定位寄存器内的值进行相加，生成新的物理地址。
$$
逻辑地址 \space+\space 重定位寄存器的值_{OFFSET} \space=\space 物理地址
$$
这使得程序可以在不连续的内存空间中运行，每次执行一个指令时，只需要将指令的逻辑地址与寄存器内的值相加获得新的物理地址。同时，程序所需加载到内存中的大小可以超过真实的物理内存大小。

## 从写程序到程序运行

1. 程序员通过各种文本编辑器写出**源代码**
2. 编译器将各个源代码转化为各个**模块**，每个目标模块都是从**0开始的逻辑地址**，相互独立，
3. 通过链接，将各个目标模块组装起来，形成一个模块，即为**可执行文件**。可执行文件拥有一个**完整的逻辑地址**。组装时，也会导入各个模块所引用的库函数，例如:stdio.h。
4. 根据不同的策略将程序装入内存，生成物理地址。

![image-20240608111126777](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158212.png)

### 三种链接方式

#### 静态链接

在程序运行之前，先将各个目标模块及他们所需的库函数链接成一个完整的可执行文件，装入模块。装入后不可拆分。

![image-20240608111438924](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158468.png)

#### 装入时动态链接

在各个模块加载的内存中时，才会链接模块所需要的库函数。其物理地址是一边装入一边形成的。

![image-20240608111610170](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158710.png)

#### 运行时动态链接

在程序执行时，只将必要运行的模块加载到内存中，加载时，对其模块进行链接。但如果一个模块没有被执行，即没有被加载到内存时，该模块不会被链接且不被加载到内存中。

![image-20240608111855121](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406081158324.png)

## 内存管理

- 操作系统负责内存空间的分配和回收

- 虚拟内存的使用和管理，对内存空间进行扩充

- 地址转换，程序员负责编写指令，数据的逻辑地址。转换为物理地址由操作系统负责，即上述中的三种装入方式。
- 内存保护，操作系统需要保证各个进程在各自的存储空间内运行，互不干扰。

### 内存保护

#### 1.上下限寄存器

在CPU中设置一对上、下限寄存器，存放进程的起始地址和结尾地址，进程指令要访问某一个地址时，CPU会检查该指令是否越界。

#### 2.重定位寄存器和界地址寄存器

重定位寄存器存放进程的**起始地址**，界地址寄存器（限长寄存器）存放进程的**最大逻辑地址**。

CPU执行过程：

1. 当进程想要访问一个逻辑地址时，该逻辑地址会先和界地址寄存器进行对比，如果没越界，则合法；如果越界，则抛出异常。
2. 合法的逻辑地址会和重定位寄存器的起始地址相加，访问真实的物理地址。

![image-20240609112758055](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091128131.png)

### 内存空间的扩充

- 覆盖技术
- 交换技术
- 虚拟存储技术

#### 覆盖技术

覆盖技术解决了程序大小超过物理内存的问题。

覆盖技术思想：将程序分为多个段（模块），常用的段常驻在内存中，不常用的段在需要时调入内存。

内存中分成一个固定区，和若干个覆盖区。在**固定区**内的指令，一旦调入后则**不能被调出**（除非程序结束）；覆盖区则在需要时调入/调出内存。

![image-20240609113707118](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091137169.png)

覆盖技术必须由程序员声明覆盖结构，操作系统完成自动覆盖。

缺点：对用户不透明，增加了编程负担。

只有早期的操作系统采用这种技术，已经成为历史。

#### 交换（对换）技术

思想：在内存空间紧张时，系统将内存中某些进程暂时换出到外存（硬盘等），把外村中某些已具备运行条件的进程换入内存中

当进程被换出到外村时，内存会保留被换出的进程的PCB（Process Control Block），PCB中保留了被换出进程的必要信息，例如在磁盘的位置等。随后将这些PCB挂起队列，即中级调度（内存调度），决定哪个处于挂起状态的进程重新调入内存。

![image-20240609114718386](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091147431.png)

问题：

1. 应该在外存的什么位置保存被换出的进程？
2. 什么时候换出？
3. 应该换出那些进程？

答：

1. 在电脑的磁盘中，磁盘被分为两个区域：对换区和文件区。

   文件区：追求存储空间的利用率，对文件区采用的是**离散分配方式**

   对换区：只占磁盘空间的小部分。对换的速度直接影响系统的整体速度，因此对换区追求换入换出的速度，通常对换区采用**连续分配的方式**。

2. 交换通常在许多进程运行且内存吃紧时进行，直到系统负荷降低。例如：许多进程运行时频繁发生缺页，说明内存吃紧，此时可以换出一些进程，直到缺页率明显下降时，暂停换出。

3. 可优先换出阻塞进程，或换出优先级较低的进程。但为了避免优先级较低的进程发生**饥饿现象**，即调入内存后很快又被换出，通常还会考虑进程在内存的**驻留时间**。

PCB会常驻内存，不会被换出。

### 内存空间的分配与回收

#### 连续分配管理

- 单一连续分配
- 固定分区分配
- 动态分区分配

连续分配：系统为用户进程分配的必须是一个**连续的内存空间**

##### 单一连续分配

在单一连续分配中，内存被分为**系统区**和**用户区**。

系统区：通常位于内存的**低地址**部分，用于存放**操作系统的相关数据**；

用户区：用于存放用户进程的相关数据。在单一连续分配中，内存只允许存在**一道用户程序**，即用户程序独占整个用户空间。

优点：实现简单，**无外部碎片**。可以采用覆盖技术扩充内存，不一定需要内存保护。

缺点：只适合单用户单任务的操作系统，不支持多道程序并发运行。存在**内部碎片**，降低存储器的利用率。

![image-20240609150935730](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091509770.png)

- 内部碎片：操作系统为一个进程分配了一段内存空间 ，用户程序并没有使用全部被分配到的内存空间，存在一些空间没有被利用。
  $$
  内部碎片\space = \space 被分配的内存空间 \space - 实际使用的空间
  $$

- 外部碎片：内存中，分配给进程的空间并不是完全连续的，进程之间存在一些细小的空间，这些空间较小且无法分配给别的进程，即为外部碎片。

##### 固定分区分配

为了支持多道程序，内存中需要装入多到程序。于是将内存划分为若干个大小的分区，每个分区只允许装入一个程序。

分区可以是大小**相等**的分区，也可以是大小**固定但不同**的分区。

![image-20240609152551701](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091525744.png)

相等：**缺乏灵活性**，程序之间的大小可能并不相同。但这种设计适合于控制**多个相同程序**的场合。

分区大小不同：增加了灵活性。

在固定分区分配中，操作系统需要建立一个**分区说明表**，来实现各个分区的分配和回收。

![image-20240609153618464](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091536508.png)

当某用户程序要装入内存时，由操作系统内核根据用户程序大小检索该表，从中找到一个能满足大小的、未被分配的分区，分配给该程序，然后将状态修改为已分配。

优点：实现简单，无外部碎片。

缺点：

1. 当程序太大时，可能没有一个分区满足该进程的需求，此时不得不采用覆盖技术来解决，但覆盖技术需要付出一定的时间代价。
2. 当程序小于分区大小，由于程序独占一个分区，会产生内部碎片。

##### 动态分区分配

动态分区分配也称为可变分区分配。

在程序装入内存时，根据进程的大小动态建立分区，该分区的大小正好适合装入进程。

![image-20240609154704409](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091547457.png)

问题：

1. 系统需要用什么样的数据结构记录内存的使用情况？
2. 当多个空闲分区都满足装入需求时，该选择哪个分区进行分配呢？

![image-20240609154811643](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091548682.png)

3. 如何进行分区的分配和回收操作呢？

答：

1. 两种数据结构来记录内存使用情况：

   - 空闲分区表：每个空闲分区都对应一个表项，表项包括分区号、分区大小、分区起始地址等信息

     ![image-20240609155115389](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091551450.png)

   - 空闲分区链：通过链表的形式，每个链表结构含有两个指针，指针分别指向地址更低的空闲分区的结束地址和下一个分区的起始地址。除外在分区的起始部分还可以记录分区大小等分区信息。

     ![image-20240609155712906](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091557948.png)

2. 当一个进程在被装入时，存在多个分区满足此进程，需要通过**动态分区分配算法**，从空闲分区表/链 中，选择一个分区分配给该进程。

3. 分配时，通过不同的动态分区分配算法：

   - 决定分配一个**空间大于此进程的分区**时，在分区表内减去被分配的空间，其**分区的数量仍然保持不变**。

     ![image-20240609160454078](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091604155.png)

   - 分配一个空间大小等于某个分区空间时，在表项内删除此分区，分区数量减1.

     ![image-20240609160636476](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091606540.png)

   回收时，

   - 当回收的进程存在一个相邻的空闲分区，则将回收后的空间添加到相邻的分区，并合并为一个分区。

     ![image-20240609160901581](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091609210.png)

   - 当回收的进程存在两个相邻的空闲分区，则将这三个分区全部合并为一个分区。

     ![image-20240609161107269](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091611322.png)

   - 当回收的进程不存在一个相邻的空闲分区，则在分区表内添加一个新的表项。

     ![image-20240609161234363](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091612409.png)

   注意：分区表的排序不一定时按照地址的递增顺序排列，具体的排列方式根据不同的动态分区分配算法来决定。

   

外部碎片解决方案

通过紧凑技术（Compaction）：利用换入\换出技术，将进程进行上下平移，此时碎片空间都会被向外挤出，形成一个大的空闲分区。重定位寄存器，保存进程新的起始物理地址，完成紧凑技术。

换入换出：

![image-20240609162825915](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091628972.png)

![image-20240609162901321](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406091629362.png)

#### 动态分区分配算法

在多个空闲分区能够被满足时，选择哪个分区进行分配？以下算法提供解决方案：

- 首次适应算法：First Fit
- 最佳适应算法：Best Fit
- 最坏适应算法：Worst Fit
- 邻近适应算法：Next Fit

##### 首次适应算法 First Fit

思想：每次从低地址开始查找，找到第一个能够满足大小的空闲分区

实现：空闲分区**从低地址开始递增排序**，每次分配内存时按顺序查找空闲分区链（或空闲分区表），配分**第一个大小能够满足的分区**。

![image-20240612143132788](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121431963.png)

##### 最佳适应算法 Best Fit

思想：为了保证较大的进程有完整连续空间，最佳适应算法会优先分配能够满足进程的最小分区

实现：空闲分区按照**容量递增排序**，每次分配内存时按顺序查找，找到**第一个能适配的分区**（最小的满足分配的分区）进行配分，分配后，需要对空闲分区表（链）进行重新排序。

![image-20240612144026750](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121440204.png)

缺点：随着分配进程增多，内存内会产生很多外部碎片

##### 最坏适应算法 Worst Fit

思想：和最佳适应算法相反，每次分配最大的分区

实现：空闲分区按照**容量递减排序**，每次分配内存时按顺序查找，找到**第一个能适配的分区**（最大的满足分配的分区）进行配分，分配后，需要对空闲分区表（链）进行重新排序。

当第一个内存满足不了的话，那就意味着没有一个分区能够分配给该进程。

![image-20240612145150082](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121451757.png)

缺点：由于大分区不断被分配，若在某一时刻有一个较大的进程需要被分配空间时，则没有分区能够被满足

##### 邻近适应算法 Next Fit

思想：由于首次适应算法每次都得从低地址开始查找，当低地址存在太多碎片时，每次查找都得经过这些地址，极大浪费了查找时间。因此，在查找时，**从上次结束的地址开始查找**，减少了查找时间。

实现：将空闲分区按照地址递增顺序排列，每次分配从上一个结束的位置开始查找。

![image-20240612150622985](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121506625.png)

缺点：与首次适应算法相比，当低地址存在一个小分区刚好满足新的进程时，邻近适应算法无法优先考虑低地址的分区，且破坏了大分区。

##### 总结

![image-20240612150941709](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121509280.png)

#### 非连续分配管理

- 基本分页存储管理
- 基本分段存储管理
- 段页式存储管理

##### 基本分页存储管理

将内存空间分为一个个大小相等的分区（比如每个分区4KB），每个分区就是一**页帧**（frame），每个页帧都有一个编号**页帧号**。（页框，页帧，内存块，物理块，物理页号），页帧号从0开始。

![image-20240612151637507](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121516910.png)

操作系统会将进程的**逻辑地址空间**分为与**页帧大小相等**的多个**页**，每个页都有自己的**页号**，也是从0开始。

![image-20240612151953624](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121519963.png)

进程的各个页都会被放在内存的页帧中。

![image-20240612152041802](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121520174.png)

###### 页表

为了能够知道进程的每个页面在内存中存放的位置，OS需要对每个进程建立一张**页表**，通常存放在PCB中。

![image-20240612152435877](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121524310.png)

页表结构

块号表示：

以一个4GB大小的内存为例，内存的页帧大小为4KB，则有
$$
页帧总数 = 2^{32} \div 2^{12} = 2^{20}页
$$
自此，我们可以使用20个bit来表示内存中所有的页帧地址，内存页帧的范围在 2^{20} - 1。

所以，块号大小为20bit，但通常计算机以字节byte为单位，即为3byte = 3B

页号：

页号不需要占空间。当我们需要某个**页i的地址**时，通过公式
$$
页_{i地址} = X_{页表在内存中的起始地址} + 3_{byte} \times i
$$
注意！页表记录的是内存块号，而不是内存块的起始地址。
$$
j_{页起始地址}= j \times 4KB_{内存块大小}
$$

###### 地址转换

进程非连续分配，但页内的地址是连续存放的。

当我们要访问某个逻辑地址A时：

1. 确定逻辑地址A对应的页号P
2. 根据页号查询页表，算出该页的起始地址
3. 确定逻辑地址A，相对于页内的偏移量W是多少

$$
物理地址_{逻辑地址A}=P_{页号在内存的起始地址}+W_{逻辑地址A在业内的偏移量}
$$

习题

![image-20240612155759558](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121558269.png)

为了方便计算机计算，通常页面大小刚好是**2的整数幂**，例如2^12B=4KB。在32位计算机中，后12位表示页内偏移W，而前面20位表示页号。这样计算机就不需要做过多的运算。

![image-20240612160457151](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121604894.png)

流程：进程需要逻辑地址A的物理地址时

1. 首先根据逻辑地址所在的页号来查询页表获取物理页号
2. 物理页号乘以页帧大小 + 虚拟地址业内偏移  = 物理地址

###### 基本地址变换机构

是一组硬件机构，用于实现逻辑地址转化为物理地址。

通常会在系统中设置一个页表寄存器（PTR），存放**页表在内存中的起始地址F**和**页表长度M**。

每个进程的页表信息都会被存放在PCB中，在进程被调度时，操作系统内核会把他们放在页表寄存器中。

流程：

操作系统进行调度时，恢复进程的PCB到处理器所对应的寄存器中。此时，页表寄存器会读取到该进程的**页表的起始地址F**（第0页的起始地址）和**页表长度M**（即该进程有多少页）

PC寄存器也会指向下一个指令的逻辑地址A

![image-20240612162546168](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121625764.png)

当操作系统查看PC寄存器后，可以很快速的将页号P和页内偏移W拆分。

![image-20240612162900422](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121629887.png)

拆分后，需要对页号P进行检查，即将页号P和页表长度（进程页数）进行对比，如果超过或者等于长度M，则意味着页号不合法。抛出越界中断。

如果合法，从页表寄存器提取出页表起始地址F和页号P相加得到内存块号

![image-20240612163449239](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121634557.png)

获得内存块号后，与逻辑地址内的页内偏移W组成物理地址，即可对内存访问。

![image-20240612163616540](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121636994.png)

例题

![image-20240612165959463](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121700387.png)

##### 具有快表的地址变换机构

###### 快表

**快表**（TLB）translation lookaside buffer,又称**联想寄存器**。是一种**访问速度比内存快很多的高速缓存**，用来存放**最近访问的页表项的副本**，可以加速地址变换的速度。于此对应，**内存中的页表称为慢表**

流程：

在CPU发送进程调度后，清空快表TLB。

![image-20240612173447123](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121734699.png)

此时，CPU在对页号合法性检测时，会先查看快表内的元素，如果命中，则直接将内存块号与页内偏移地址组合获得物理地址。否则如同之前一样，访问内存内的页表（慢表），获取页号所对应的内存块号，再和页内偏移组合形成物理地址。

![image-20240612173726894](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121737495.png)

若通过页表获取内存块号后，CPU会在快表内记录刚刚从内存中获取的内存块号，和与之对应的页号进行映射，存入快表。

![image-20240612174003312](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121740960.png)

在后续的执行中，若CPU没有发生进程调度，且命中快表，则加速了对该逻辑地址的转化，来访问内存。

由于快表的容量很小，在快表被填满后需要根据一些置换算法来进行替换。

快表和慢表同时查找和分别查找

![image-20240612175023409](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121750935.png)

假设查询快表需要1us, 查询慢表（访问内存）需要100us。快表的命中率为90%。则期望为：

- 分别查找（先快后慢）

$$
(1\mu s_{快表查询} + 100 \mu s_{访问内存})\times 0.9 + (1\mu s_{查询快表} + 100\mu s_{查询慢表} + 100\mu s_{访问内存})\times 0.1 = 111 \mu s
$$

- 同时查找

$$
(1\mu s_{快表查询} + 100 \mu s_{访问内存})\times 0.9 + ( 100\mu s_{查询慢表} + 100\mu s_{访问内存})\times 0.1 = 110.9 \mu s
$$

###### 局部性原理

- **时间局部性**：在一条指令被执行后，一段时间后再次被执行。

  例：在一个循环内，i++指令被重复执行

- **空间局部性**：连续访问一个连续的内存空间。

  例：在一个for循环内，连续访问一个数组

引入快表和未引入快表的区别：

- 在未引入快表时，访问一个逻辑地址需要访问两次内存
- 引入快表后，在命中快表时可以只访问一次内存
- 引入快表后需要对快表进行一次查询，且在命中后将内存块号和页号保存到快表中

###### 两级页表

用于解决单极页表存在的缺陷。

**单级页表的缺陷**：

- **页表开销过于庞大**

假设某计算机按字节寻址，支持32位逻辑地址，采用分页存储管理，页面大小为4KB，块号长度为4Byte。

页内寻址需要12bit来偏移寻址。所以剩下32-12=20bit来用于指明内存块号。即最多可拥有1M的页数。当所有内存块被分配时，则页表需要
$$
1M \times 4Byte = 2^{20} \times 2^{2}B = 2^{22}B
$$
来对应内存内的所有内存块号。

由于一个页的大小为4Byte，所以需要以下页帧来存储：
$$
2^{22} \div 2^{12} = 2^{10}页
$$
即1K页来表示，这意味着需要分配1K页的**连续空间**给**页表**。这个**开销过于庞大**，已经丧失了离散存储管理的优势。

- **局部性原理**

由局部性原理可知，有时候进程执行不需要知道整个进程的所有页号，**进程只需要访问几个页面即可正常运行**，因此没有必要将整个页表都常驻在内存中。

解决思路：我们可以将进程的页进行分组，使得每个内存块刚好可以放入一个分组。

例：页面大小4K，块号长度4B；则每页可以存放1K的块号。因此每1K个连续的页为一组，每组刚好占一个内存块。

获得分组后，为了使得分组能够连续，需要再次建立一张页表，即称为**页目录表**（外层页表、顶层页表）。

![image-20240612184452887](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121844896.png)

将原本的大页表分成多个小页表，即为**二级页表**，二级页表离散分布在内存中，二级页表由页目录表来管理。

![image-20240612184808529](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121848945.png)

如图所示，0#页表被存放在3号内存块中。

此时，虚拟地址的编址也需要发生变化。

![image-20240612185336303](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406121853903.png)

自此，解决了页表需要连续存放在内存的问题。

其二，根据局部性原理，不需要将整个页表放入内存，将会采用**虚拟内存技术**，将页表的大部分**存放在磁盘**上。

实现：在页表的每一个页表项添加一个**标识位**，用于**记录是否被调入内存**中。

![image-20240613093128933](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406130931612.png)

当进程需要访问的虚拟地址不在内存中时，操作系统会产生一个**却页中断**，然后**将目标页面从外存调入内存**。

多级页表缺点：访问一个虚拟地址时，没有快表的情况下需要访存次数为
$$
n_{页表级数} + 1_{虚拟地址对应的物理地址}
$$

##### 基本分段存储管理

分段：进程的地址空间会按照**自身的逻辑**关系**划分为若干个段**，每个段都有一个段名，每段从**0开始编址**。

![image-20240613095057495](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406130950126.png)

操纵系统是以**段为单位分配**，在为每个段分配空间时，**每个段在内存中必须占据连续的地址空间**，但各个**段之间可以不相邻**。

有了段名，程序员可以更方便的进行编程。在对代码进行编译时，编译器会为每个段名替换一个段号。

此时，逻辑地址也需要发生改变。

![image-20240613095656578](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406130956122.png)

值得注意的是，**段号的位数**决定了每个**进程最多可以分几个段**，**段内地址**位数决定了**每个段的最大长度**是多少。

例：根据图中所示
$$
16_{31至16段号} \rightarrow 2^{16} = 64K个段
$$
每个段的长度（大小）为：
$$
16_{15至0段内地址} \rightarrow 2^{16} = 64KByte
$$
![image-20240613100621064](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131006607.png)

在编译时，段内的单元即为段内地址，段名转化为段号。

###### 段表

和分页机制相同，操作系统需要为每个进程建立一张段表，段表项一一映射各段的基址和段号，且保存了段长（大小）。

![image-20240613101123197](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131011853.png)

可以发现，与段表相比，多出了段长这个元素。其原因是页管理机制中，**页的大小相同**，但**段的长度并不相同**。

段表大小

假设计算机系统为32位虚拟地址寻址，其中前16位为段号，后16位为段长，内存大小为4GB。

则每个段的最大空间为
$$
2^{16}Byte = 64KByte
$$
内存寻址需要的最小位数：
$$
4GB = 2^{32} \rightarrow 32位
$$
所以，每个段表的表项大小为
$$
16_{段号位数} + 32_{内存寻址的最小位数} = 48位 \rightarrow 6Byte
$$
和页表一样，段号不占空间，其公式为：
$$
M_{段表起始地址} + K_{项段号} \times 6_{表项大小} = 段表项地址
$$


虚拟地址和物理地址转化过程：

首先，在CPU进行调度时，从进程的PCB中恢复寄存器信息，这个过程会将恢复段表寄存器。

![image-20240613103439530](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131034106.png)

此时，CPU得知该进程的段表在物理内存中的位置

![image-20240613103616119](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131036482.png)

恢复后，CPU读取PC寄存器中的下一条指令，即虚拟地址。该虚拟地址包含了段号和段内地址，CPU会对其段号与段表长度进行对比

![image-20240613103813533](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131038988.png)

当段号大于等于段表长度，CPU发出越界中断，否则继续执行。

随后，根据**段表始址**，在**内存中找到段表**。根据段表项寻址公式，找到所需的段表项在内存中的位置

从段表项中提取**段长**和虚拟地址中的**段内地址**进行对比，若内地址**大于等于段长**，意味着已经**超出该段的范围**，发出中断

![image-20240613110416006](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131104561.png)

然后**提取出该段号所对应的基址**，与虚拟地址中的**段内地址相加**得到物理地址

![image-20240613110521641](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131105031.png)

由于段的大小不等，与分页管理机制相比，多出了对段内偏移和段长的比较。

###### 分页分段的区别

页是信息的物理单位，其目的为实现离散分配，提高内存利用率，分页是一种系统行为，对用户不透明

段是信息的逻辑单位，分段的目的是为用户提供更好的编程需求，分段是对用户可见的（每个段都是由用户编写）。

分段比分页更容易实现代码共享保护

例：若两个进程共享一段代码，则只需要在表项内的段基址指向同一个地址即可

![image-20240613111709657](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131117245.png)

注意：共享代码一般为纯代码，不属于临界资源，进程之间不会修改同一个变量等，防止出现数据不一致。

**为什么页式管理不能做到代码共享？**

因为在页式管理中，代码是按照页的大小等量划分，一个页面中可能存在多个模块的代码。因此，无法决定共享代码的基址。

![image-20240613112236693](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131122154.png)

访存次数：

- 分页，取决于级数，一级一次，两级两次
- 分段：两次，第一次访问段表，第二次内存单元

分段机制也可以引入快表机构，将近期访问的段表保存着快表中，后续若命中快表则不需要访问内存查询段表，直接访问内存单元。

##### 段页式管理

分段+分页结合的一种管理方式

###### 分页分段优缺点分析

优点：

- 分页：内存空间利用率极高，存在少量的内部碎片
- 分段：很容易按照模块进行分段

缺点：

- 分页：不便于按照逻辑模块实现代码共享

- 分段：如果段过长，其需要很大的连续空间；且段式管理会产生外部碎片，需要通过紧凑技术压缩外部碎片形成较大空闲分区

  ![image-20240613113712878](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131137640.png)

###### 段页式

在进程按照逻辑模块分段以后，每个模块再按照页来划分。

![image-20240613113937459](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131139079.png)

内存中，还是以页为单位的内存块进行划分

![image-20240613114040483](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131140896.png)

###### 逻辑地址结构

此时，逻辑地址结构也需要发生改变

![image-20240613114133359](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131141776.png)

由此可见，段内地址被划分为页号和页内偏移地址。

**段号位数**：决定了每个进程最多可以分成几个段

**页号位数**：决定了每个段最大页数

**页内偏移位数**：决定了页面大小

例：在一个32位寻址系统中，按字节（Byte）编址,段号位数为16位，页号为4位，页内偏移为12位，则

最大段数：
$$
2^{16} \rightarrow 64K个段
$$
每个段的最大页数：
$$
2^{4} \rightarrow 16页
$$
页的大小：
$$
2^{12} \rightarrow 4KByte
$$
分段式对用户可见的，但段内分页是对用户不可见的。系统会根据内段地址自动划分页号和页内偏移。

###### 段表和页表结构

在段页式管理中，段表不再存储该段的基址，而是存储该段所对应的**页表基址**。而段表长度则改外**页表长度**。

![image-20240613115235610](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131152257.png)

此时，一个进程会对应一个段表，而一个段表会对应多个页表

![image-20240613115550987](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131155462.png)

###### 逻辑地址转物理地址流程

和之前一样，在CPU发生进程调度时，会设置段表寄存器。

设置完以后，将段号和段表长度进行对比，判断是否越界

![image-20240613115844083](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131158554.png)

然后根据段表始址查询段表，再根据段号，计算出对应的段表项。

由于各个模块的大小不同，所以每个模块的页数都不同，为了排除越界风险，需要将虚拟地址这种的页号与段表中的页表长度进行对比。

![image-20240613120525854](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131205347.png)

从段表项内提取出页表长度与页号进行对比，若不越界，提取出页表存放在物理内存的块号（即页表物理地址），再根据页表找到对应的页表项，计算出逻辑地址所需要的内存块地址，在根据页内偏移量，和内存块地址进行组合形成最终的物理地址。

![image-20240613120758616](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131207035.png)

根据最终的物理地址，访问内存单元。

在没有引入快表的情况下，需要对内存进行3次访存。引入快表后，快表可以记录最近访问的段号和页号，进行快速访存。

### 虚拟内存

#### 传统存储管理方式的特征和缺点

在传统存储管理方式中，事实上，根据局部性原理可知，在一个进程运行时并不需要在内存中存放大量的指令和信息。但传统的存储管理一次性将作业（进程）装入到内存中，会引发两个问题：

1. **一次性**：传统管理方式希望**一次性**将作业装入内存中，当作业非常庞大时，内存无法承载过大的作业。当大量作业异步运行时，内存无法容下所以的作业，只允许少量作业运行，导致**多道程序并发度下降**。
2. **驻留性**：一旦作业被装入内存时，则会一直驻留在内存中，直到停止\结束运行。但事实上，一个进程运行时，只需要一小部分的数据即可正常运行。这就导致其余的数据大量占据了内存的空间，浪费资源。

#### 虚拟内存的定义和特征

基于局部性原理，在程序装入内存时，只需**将必要的部分装入内存**，其余的部分存放在外存即可。

当程序运行时需要**访问不在内存内的信息**时，操作系统会负责将所需的信息**从外存调入内存**，程序方可继续执行。

当内存的空间不够时，操作系统会将**暂时用不到的信息换出到外存**，为需要的信息腾出空间。

在操作系统的管理下，用户们会认为自己有着较大的内存空间，即虚拟内存。

##### 虚拟内存的三个特征

- **多次性**：无需在作业运行时一次性装入内存，而是允许被分成多次调入内存。
- **对换性**：进程无需一直驻留在内存中，允许被换出到外存中，外存内的进程也可以被换进内存。
- **虚拟性**：从逻辑上扩充了内存的容量，但实际上内存的大小不变。

#### 虚拟内存的实现

通常，虚拟内存的实现是建立在**离散分配的内存管理**。

**为什么不能基于连续分配方式呢？**

因为当作业的大小有**很大差异**时，连续的内存空间需要多内存**进行紧凑**技术来腾出空间，极大的**浪费资源**。

和传统的离散管理方式，操作系统需要负责从外存将进程/信息换进内存中。因此，操作系统需要提供**请求调页（请求调段）**的功能

在内存空间不足时，操作系统需要提供**页面置换（段置换）**功能

实现方式：

- 请求分页存储管理
- 请求分段存储管理
- 请求段页存储管理

##### 请求分页管理

- 页表机制
- 却页中断机构
- 地址变换机构

与基本分页管理相比，请求分页管理为了实现**请求调页**，操作系统需要知道**每个页面是否调入内存**，如果没有调入，那么操作系统需要知道**页面在外存被存放的位置**。

当**内存空间不够时**，请求分页管理为了实现**页面置换**，操作系统需要通过某种算法来**决定哪个页面应该被换出**，从**页面的修改信息**角度出发，当一个页面尚未被修改时，那么从外存调入的数据可以直接覆盖。因此**操作系统需要记录各个页面的修改信息**。

###### 请求页表

因此，请求分页管理的页表中，添加了新的信息：

![image-20240613142135272](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131421135.png)

**状态位**：表明该页是否在内存中，当状态位为0时，表示不在内存中

**访问字段**：可以是记录最近被**访问过的次数**，或记录**上次访问的时间**。操作系统可以基于访问的**频率**或**访问的时间**来决定是否**换出该页面**

**修改位**：页面**是否被修改**。没有被修改过的页面**不需要写回外存**，可直接覆盖，节省写回外存的时间；相反，若被修改过，则需要**写回外存**。

**外存地址**：页面在外存被**存放的位置**

###### 却页中断机构

当我们访问的页面不在内存时，便会产生一个却页中断，由操作系统的**却页中断处理程序**来处理该中断。

![image-20240613143353222](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131433981.png)

此时，**缺页的进程进入阻塞状态**，被操作系统放入阻塞队列。在**调页完成**后再将其唤醒，放入**就绪队列**中。

操作系统根据**外存地址**进行IO操作，将**缺失页面放在内存**的空闲块中

![image-20240613143851983](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131438480.png)

且修改表项对应的内容

![image-20240613144010430](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131440035.png)

若内存中**没有空闲块**，则操作系统需要通过**页面置换算法**来**淘汰**一个页面，若该页面**被修改过**，则需要**写回外存**；否则，**直接覆盖**。

###### 逻辑地址转化物理地址

和传统页式管理类似，多出了几个新的步骤：

1. **判断**需要访问的页是否在内存中
2. 在新的页面调入时，内存没有更多空闲空间，则需要**请求一次页面置换**
3. 每当一个页面被访问或被换入换出，都需要**对表项进行修改**

流程：

1. 检查页号是否越界

   ![image-20240613145350581](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131453305.png)

2. 查看快表是否命中，若命中，直接访问物理地址

   ![image-20240613145729976](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131457616.png)

3. 若没有命中，查看慢表，通过状态位判断是否在内存中。若不存在，则由操作系统的中断处理程序来处理缺页中断。**此时注意**！若**快表内页面被置换**，需要**清楚被换出的页面的表项**，否则可能会**访问错误的页面**！！！

4. 若没有命中，查看慢表，再通过页内偏移组合访问物理内存单元，并将访问的页面记录在快表和慢表中

   ![image-20240613150010974](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131500786.png)

细节补充；

1. 只有“写指令”才需要修改“修改位”。
2. 一般来说，对表项的修改一般在快表内进行。在删除快表内的某一个表项时（即某页从内存中被换出），才会将被删除表项复制的慢表中，这样减少了访存次数。

##### 页面置换算法

在**内存不够**时，操作系统**通过页面置换算法**，**选择一个用不到的页面信息换出到外存**。

页面置换需要通过**I/O操作**进行，所以，页面置换的**开销相对而言比较大**，因此，页面算法应该**追求更少的缺页率**（即尽可能少的换入换出）。

- 最佳置换算法（OPT）
- 先进先出置换算法（FIFO）
- 最近最久未使用置换算法（LRU）
- 时钟置换算法（CLOCK）
- 改进的时钟置换算法

###### 最佳置换算法（OPT）

最佳置换算法（OPT，optimal），每次选择**永不再用**或在**最长时间内不再被访问的页面**进行淘汰，保证最低的缺页率。

例：

![image-20240613152919569](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131529254.png)

在置换页面时，观察访问页面的序列，将最后一个出现的页面进行置换。

如图所示，在箭头指向的这个时刻，0和1页面相继出现过，所以选择7号页面进行淘汰

值得注意的是，缺页中断的次数并不等于页面置换次数。在一个页面调入内存时，如果有空闲块则无需进行页面置换。

###### 缺页率公式

$$
缺页率 = \frac {缺页中断次数}{访问页面的次数}
$$

在该题中，缺页率：
$$
\frac {9}{20} = 45\%
$$
最佳置换算法只是一种**理想算法**，实际上我们**无法得知访问页面的次序**，因此最佳置换算法时**无法实现**的。

###### 先进先出置换算法（FIFO）

每次选择淘汰的页面是**最早进入内存的页面**。

实现方法：通过一个**队列**（先进先出），根据**时间线**将进入内存的页面放进队列中，每当出现一次**缺页置换**时，**移除队列的第一个元素**（即最早进入队列的页面）。**队列的大小取决于系统分配给进程的内存块数**。

例：

![image-20240613160513869](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131605606.png)

如图所示，该进程被分配了3个内存块，在执行的过程中，产生了9次缺页。

我们将题目进行修改，为进程分配4个内存块

![image-20240613160925603](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131609140.png)

我们会发现，增加了一个内存块分配，产生了10次缺页。惊奇的发现增加内存块的分配反而增加了缺页次数。

###### Belady异常

当为进程分配的物理块数增大时，会产生缺页次数不减反增的异常现象。

事实上，只有FIFO算法会产生Belady异常。

该算法实现简单，但与进程实际的运行规律不同，因为**先进入**的页面有**可能是经常被访问**的页面。因此该算法的**性能较差**。

###### 最近最久未使用置换算法（LRU）

最近最久未使用置换算法（LRU，least recently used），每次淘汰的页面是最近最久未使用的页面。

实现方法：

此时页表的表项内的访问字段记录页面被访问的时间t，当需要淘汰一个页面时，只需将
$$
max(当前时间 - t_{表项i}) = i
$$
i即为需要被置换的页面。

例：

![image-20240613162400541](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131624351.png)

在箭头指向的这个时刻，7号页距离当前时间最久远的表项，因此新页面3将会替换7号页面

实际中，最近最久未使用置换算法需要**专门的硬件支持**，虽然算法**性能好**，但是**实现困难**，**开销较大**。

###### 时钟置换算法（CLOCK）

又称为最近未用算法NRU（not recently used），是一种性能和开销比较均衡的算法。

次算法分为两种形式，简单的和较复杂的

**简单的CLOCK算法**：

在页表中引入访问位，1表示最近被访问过，0则最近没有被访问过。将内存中的页面都通过指针链接成一个循环队列。当某页被访问时，其访问位置成1。

当需要淘汰一个页面时，对该循环队列进行遍历，若访问位为1，则将它置为0，如果为0，则置换。

在极端的情况下，访问队列全部为1，则会进行两次遍历：第一次将所有的访问位置为0，第二次将第一个遇见的0置换出去。

例：

![image-20240613164010205](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131640906.png)

依次将1，3，4，2，5链接成一个单向循环队列

![image-20240613164021610](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131640226.png)

在来到指针指向的这个时刻时，对单向循环列表中的所有访问位依次置为0，指针回到原先指向的位置

![image-20240613164325876](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131643999.png)

随后，将首个访问位为0的页面置换出去，例中为1号页面，然后指针指向下一个页面。

![image-20240613164509571](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131645197.png)

在后续的执行中，指针的位置保持不变，只需要将近期访问过的页面的访问位进行修改即可。一旦一个访问的页面需要被换入内存时，指针开始扫描。将1置为0，将0置换出去。以此类推。

![image-20240613164928346](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131649134.png)

回到例中，指针从3号页开始旋转，分别将3，4号页置为0 。来到2号页，发现2号页的访问位为0，于是换出2号页，将7号页换入并将访问位置为1，指针指向下一页（5号页）。

**改进的时钟置换算法**：

**简单版本**只考虑了该**页面最近是否被访问过**。

事实上，如果被淘汰的页面**没有被修改过**，则**不需要执行I/O操作进行回写外存**。只有**被修改**过且**被淘汰**的页面才需要**写回外存**。

因此，在页表内引入修改为，0为页面未修改，1为页面被修改。

访问位和修改为组成一个二维向量
$$
(访问位,修改位)
$$
（1，1）则表示该页面近期被访问过且被修改过。

**算法改进**：

将所有可能被置换的页面排成一个循环队列，开始第一轮扫描。

**第一轮**：从当前位置开始扫描，扫到第一个（0，0）的页进行置换，本轮扫描**不修改任何标识位**。

**第二轮**：若第一轮扫描失败（即没有找到0，0的页），尝试找到（0，1）的页置换，**本轮扫描将所有扫描过的访问位置为0**。

**第三轮**：若第二轮扫描失败（即没有找到0，1的页），尝试找到（0，0）的页进行置换，**本轮扫描将不会修改任何标志位**。

**第四轮**：若第三轮扫描失败（即没有找到0，0的页），找到第一个（0，1）的页用于置换。**此轮一定会找到一个（0，1）的页**，因为第二轮已经将所有的访问位置为0。

改进后的算法选择一个淘汰页面最多会进行**4次扫描**。

扫描轮次解读：

事实上，是按照置换的优先级进行扫描，优先级较高的先被淘汰

第一轮优先级：最近没访问，且没修改的页面 （0，0）

第二轮优先级：最近没访问，但修改过的页面 （0，1）

第三轮优先级：最近访问过，但没修改的页面 （1，0）

第四轮优先级：最近访问过，且修改过的页面 （1，1）

能进入第四轮扫描说明每个页面在近期都被访问过且修改过。

#### 页面分配策略

##### 驻留集

指的是请求分页存储管理中给进程分配的物理块集合。

在支持虚拟存储技术的系统中，**驻留集的大小**一般**小于进程的总大小**。

若驻留集太小，进程过大，则会频繁产生缺页中断，系统需要花费大量时间处理中断；若驻留集太大，则占据了太多的内存空间，导致资源浪费。

因此，选择一个合适的驻留集是非常重要的，提出了两种策略：

1. **固定分配**：操作系统会为每个进程分配一组固定数目的内存块，在进程运行期间不再改变，即**驻留集大小不变**。
2. **可变分配**：操作系统先为每个进程分配一定数目的内存块，在进程运行期间，可根据当前情况，适当的增加或减少驻留集，即**驻留集大小可变**。

对置换也提出两种策略：

1. **局部置换**：发生缺页时，只能选进程自身的内存块进行置换
2. **全局置换**：可以将操作系统保留的空闲内存块分配给缺页进程，也可以将别的进程持有的内存块换出到外存，再分配给缺页进程。

我们可以对这些策略进行组合

![image-20240613173158690](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131731378.png)

我们发现，固定分配无法和全局置换进行组合，会导致自己不再是固定分配，转变为可变分配。

###### 固定分配局部置换

系统为各个进程分配一定数量的内存块，在运行期间驻留集大小不变。若进程发生缺页，只能够置换自己的内存块。

缺点：**很难确定**为每个进程分配的**内存块数量**。采用这种策略的系统通常需要结合进程大小，优先级，等等参数来确定内存块分配数量，灵活性较差。

###### 可变分配全局置换

系统为各个进程分配一定数量的物理块，操作系统会保持一个空闲内存块队列。当某个进程发生缺页时，从空闲内存块队列中分配一个内存块给进程；若空闲块的数量为0时，系统会选择**未被锁定的页面**换出外存，再将其分配给缺页进程。

**什么是未被锁定的页面？**

操作系统会标记一些非常重要的页面，这些页面不会从内存中被换出，即为锁定页面。其未锁定指的是，对于操作系统来说，是一些可有可无，非必要的页面，他们允许被换出内存。

采用这种策略的系统，一旦进程发生缺页，就会**获得一个新的内存块**。当**内存空闲块用完**时，操作系统会选择一个未锁定的页面进行置换，**被置换的页面可能是别的进程的页面**，其进程可能会产生**缺页**，**增加了缺页率**。

###### 可变分配局部置换

操作系统会为每个进程分配一定数量的内存块，当某个**进程发生缺页**时，只允许**从自己的内存块中置换页面**。如果该进程**频繁的产生缺页**时，操作系统**会适当分配给他更多的物理块**，直至缺页率**趋于一个适当的程度**；反之，若某个进程的**缺页率非常低**，操作系统就会适当的**减少它的内存块数**。

##### 调入页面策略

在什么时候调入所需要的页面呢？提出两种策略。

1. 预调页策略：根据局部性原理（空间局部性），一次调入若干个相邻的页面，相比于一次调入一页效率更高。但如果调入的页面大多数没有被访问，反而降低了效率。因此，该策略预测不久过后可能被访问的页面，将他们预先调入内存中，减少对外存进行I/O操作。但目前的预测成功率只有50%左右。故这种策略**主要用于进程的首次调入，即运行前调入**，通常有程序员指出。例如：先将main函数所对应的页调入内存中。
2. 请求调页策略：**进程在运行期间发现缺页时才将所缺页面调入内存**。由这种策略调入的页面一定会被访问，但一次仅限于一页，这意味着每次调页都需要和磁盘进行I/O操作，因此开销较大。

##### 调入内存过程

外存（磁盘）通常分为：

- 对换区（采用连续分配方式，读/写速度更快）
- 文件区（采用离散分配方式，读/写速度更慢）

1. 当系统拥有足够的对换空间，页面的换入换出都是在内存和对换区进行，保证换入换出速度。在进程运行之前，需要将进程的相关数据从文件区复制到对换区，然后对换区和内存再进行换入换出操作。

![image-20240613182336402](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131823433.png)

2. 若系统没有足够的对换空间，凡是不会被修改的数据则会直接从文件区调入，由于这些数据不会被修改，因此换出时不必再写回外存，在需要时直接从文件区读取。对于可能被修改的数据，仍然通过对换区进行换入换出操作。

![image-20240613182725035](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131827023.png)

3. UNIX方式：第一次被调入的页面直接从文件区调入，在进程需要置换页面时，页面被调出到对换区，之后若还需要该页面则直接从对换区调入。

![image-20240613183022025](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131830611.png)

##### 抖动（颠簸）现象

刚刚换入\换出内存的页面，马上又被换出\换入外存。其原因为进程频繁访问的页数高于系统分配给进程的驻留集，即系统分配给进程的内存块不够多。

系统会花费大量时间处理缺页中断，因此我们要避免这种现象发生。

###### 工作集

为了解决抖动（颠簸）现象，提出了工作集的概念。

指的是某段时间间隔里，进程实际访问页面的集合。

操作系统会根据窗口尺寸来算出工作集。

例：假设一个进程对页面的访问序列如下，窗口尺寸为4，指针指向的时刻的工作集为当前的页面向前数窗口尺寸个页面，即为当前的工作集

![image-20240613184718085](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131847762.png)

可以发现，工作集的大小有时小于窗口尺寸。

在实际应用中，操作系统会统计工作集大小，根据工作集大小给进程分配若干个内存块。

例如：一个进程的窗口尺寸为5，经过一段时间的检测发现该进程的工作集最大为3，说明该进程有很好的局部性，为该进程分配3个以上的内存块即可满足进程运行需求。

一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将会产生频繁的缺页，抖动现象。

#### 内存映射文件

内存映射文件（Memory-Mapped Files)

是操作系统向上层程序员提供的功能（系统调用）

- 方便程序员访问文件数据
- 方便多个进程共享同一个文件

在传统的文件访问方式中，访问文件流程：

1. open系统调用，打开文件
2. seek系统调用，将读写指针指向某个偏移位
3. read系统调用，从读写指针指向的地址开始，读取若干个数据（从磁盘写入内存）
4. write系统调用，将内存中的指定数据写回磁盘（根据读写指针确定要回写到什么位置）
5. close系统调用，关闭文件

![image-20240613190726620](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131907495.png)

内存映射文件方式流程：

1. open系统调用，打开文件
2. mmap系统调用，将文件映射到进程的虚拟地址中，返回一个映射虚拟地址的起始位置的指针。

此时，文件并没有真正的被读取到内存中，只是将文件内容的虚拟地址映射到内存中，在程序员需要进行读写时，才会从系统中调入内存。程序员不需要通过seek, read, write来偏移\读取\写入数据。由操作系统自主完成。程序员只需要通过mmap返回的指针进行偏移操作即可。

在程序关闭时，操作系统会自动将修改的部分写回磁盘。

![image-20240613191413373](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131914317.png)

文件共享的实现：

多个进程的虚拟地址空间内会对需要被共享的文件进行地址映射，一旦共享的文件被修改（物理内存的数据被修改），由于是映射关系，其余的进程能够立马感知的数据被修改，实现文件共享。

![image-20240613191853122](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406131918981.png)

# 文件管理

## 文件基本概念

计算机中存放了各种各样的文件。

- 那么，文件都有哪些属性呢？
- 文件内部的数据应该怎样组织起来呢？
- 文件之间又应该怎么组织呢？
- 从操作系统的角度考虑，如何才能方便用户、应用程序使用文件呢？
- 文件数据应该怎么存放在外存呢？

### **文件的属性**

- **文件名**，同一个目录下不允许存在相同文件名的文件
- **标识符**，文件名并不能唯一标识文件，操作系统会为每一个文件生成一个唯一标识符，此标识符对用户来说毫无可读性。
- **文件类型**，操作系统可以通过文件类型为他们设置一个默认软件来打开文件
- **文件的位置**，文件的存放路径
- 文件的大小、创建时间
- 文件的保护信息，操作系统会将用户分组，每个分组对文件的访问权限可能不同

### 文件结构

- **无结构文件**（流式文件）：如文本文件，二进制文件等无结构文件。
- **有结构文件**：例如数据库，由一条一条的记录组成，每个记录都是由数据项组成。数据项是文件系统中最基本的数据单位。

### 文件之间的组织

- 根目录：盘符，D盘，C盘等
- 文件夹（是一种特殊的有结构文件），在根目录下，可以创建一层一层的目录来存放文件

### 操作系统为上层提供的基本功能

- **创建文件**，通过create系统调用创建
- **读文件**，将文件数据读入内存，才能让CPU处理。双击文件后，操作系统通过调用read系统调用，将文件数据从外存读入内存，并显示在屏幕上
- **写文件**，在我们按下保存按钮后，操作系统会调用write系统调用，将修改后的文件数据从内存写回外存
- **删除文件**，操作系统通过调用delete系统调用从外存删除文件
- **打开文件**，系统调用open，在读写文件之前，需要打开文件
- **关闭文件**，系统调用close，在读写结束后调用

较复杂的功能可以通过以上的基本功能组合而成，例如复制文件，先创建一个新的文件，再把源文件写入内存，再将内存中的数据写入新的文件。

### 文件外存存放

和内存相同，外存也是由一个个的存储单元组成，每个存储单元可以存储一定量的数据，例如1Byte。每个存储单元都对应着一个物理地址。

外存也会被分为一个个磁盘块\外存块，每个磁盘块的大小是相等的。

文件的逻辑地址也可分成逻辑块号，块内地址。同样的，操作系统也需要将文件的逻辑地址转换为物理地址。块内地址的位数取决于磁盘的大小。

操作系统以块来分配存储空间，因此即使一个文件的大小远小于存储空间的大小，也会占据一个外存块。

外存的读入内存时，同样以外存块为单位。

### 操作系统实现的其他文件管理功能

- 文件共享：多个用户可以共享一个文件
- 文件保护：保证不同的用户对文件有不同的操作权限

## 文件的逻辑结构

文件的**逻辑结构**指的是，在**用户**看来，文件内部的数据应该时如何组织起来的

文件的**物理结构**指的是，在**操作系统**看来，文件的数据是如何存放在外存的

- 无结构文件
- 有结构文件

文件操作的具体实现与逻辑结构、物理结构都有关。

线性表：是一种逻辑结构，可以用不同的物理结构实现，例如：顺序吧/链表。顺序表在逻辑上相邻，在物理上也相邻；链表在逻辑上相邻，但在物理上不相邻。

因此，顺序表可以实现随机访问，而链表无法实现。

### 无结构文件

文件内部数据就是一系列二进制流或字符流组成。又称为“**流式文件**”。例如：windows的txt文件。

### 有结构文件

由一组有相似记录组成，又称“**记录式文件**”。每条记录由若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为**关键字**（作为识别不同记录的ID）

![image-20240614093247645](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406140932115.png)

如图所示，学号、姓名、性别、专业即为关键字。

后续的每一行都为一条记录，每一条记录都由若干个数据项组成。

根据各记录的长度（占用磁盘/内存的空间）是否相等，可分为：

- 定长记录
- 可变长记录

#### 定长记录

每一条记录的大小都相等。根据上面的图片：

![image-20240614093708982](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406140937371.png)

记录的每一项数据项的大小固定，且按照固定的顺序来记录数据项。

#### 可变长记录

每条记录的大小可能不相等。

![image-20240614094053984](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406140940383.png)

如图所示，每个人的特长数据项大小并不相等，因此，特长这个数据项的大小是不确定的，有的人甚至没有特长。

因此，每条记录的结构应该如下：

![image-20240614094214712](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406140942080.png)

#### 有结构文件的逻辑结构

为了表示这种非确定长度的记录，引入有结构的逻辑结构：

- 顺序文件
- 索引文件
- 索引顺序文件

##### 顺序文件

文件中的记录在**逻辑**上，一个接一个地**顺序排列**，记录可以是**定长**或**可变长**的。各条记录在**物理**上可以是**顺序存储**或**链式存储**。

![image-20240614094710200](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406140947570.png)

顺序文件又分为两种结构：

- **串结构**：记录之间的顺序**与关键字无关**，按照记录**存入的时间**决定**记录顺序**
- **顺序结**：记录之间的顺序**按关键字顺序排列**

问题：

当我们已经知道一个文件的起始地址（第一条记录的位置）的前提下：

1. 能否快速找到第i条记录对应的地址？ （即能否实现随机存储）
2. 能否快速找到某个关键字对应的记录存放的位置？

答：

取决于存储方式。

1. 当采用**链式存储**时，无论是**定长**还是**可变长**，**都无法实现随机存取**，只能从第一条记录依次往后寻找。为什么？

   因为链表无法根据索引来快速获取内容，必须从链头开始遍历，依次向后寻找。

2. 当采用**顺序存储**时，可**变长**记录也**都无法实现随机存取**，也只能从第一条记录依次向后查找。为什么？

   在可变长记录中，我们并**不知道每条记录的具体长度**，此时需要一个一个数据项来表明每条记录的长度。

   ![image-20240614095909348](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406140959743.png)

   如图所示，每条记录L的**长度大小可能不同**，**没有一定的规律**来组织长度，因此在查找**记录i**时，只能够将之前的记录长度和角标i相加才能得出i记录的地址。
   $$
   地址_{i记录}= i_{角标} + \sum_{n = 0} ^{i-1} L_{n}
   $$

3. 当采用**顺序存储**，**定长**记录**可以实现随机存取**。为什么？

   由于**每条记录大小相等**，此时**角标的使用就有意义**，只需要**通过角标来快速定位**即可。

   ![image-20240614100951968](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141009372.png)
   $$
   地址_i = L_{记录长度} * i
   $$
   此时考虑物理结构：

   - 若采用**串结构**，则**无法快速找到某个关键字对应的记录**。因为在物理层面上，**每条记录之间的顺序与关键字无关**，只与**时间顺序有关**。
   - 若采用**顺序结构**，则**可以实现对关键字的快速查找**，因为顺序结构是以**关键字顺序来记录**。

串结构和顺序结构的缺点：

- 串结构无法快速查找某个关键字
- 顺序结构的文件，在增加/删除一条记录时，需要挪动所有记录的位置，开销较大。

在实际应用当中，为了减少频繁的I/O操作，操作系统会管理一个日志文件，会记录一个文件的修改信息，在一段时间后，统一的修改回磁盘中。

##### 索引文件

为了实现可变长记录的随机访问，引出了新的数据结构。

###### 索引表

索引表是一个定长记录的顺序文件，因此通过索引号快速的查找某条记录，在根据指针找到可变长的记录。

索引表由三个关键字组成：

- 索引号
- 长度：记录长度
- 指针：指向对应记录

![image-20240614102445649](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141024040.png)

文件可以离散的存放在磁盘上。

当增加/删除一条记录时，需要对索引表进行修改。

索引表适用于信息处理及时性较高的场合。

索引表可以通过不同的关键字作为索引号，我们可以用学号作为索引号，也可以以姓名作为索引号。

##### 索引顺序文件

首先思考一下索引表的缺点：

每条文件记录都对应着一个索引表表项，当记录的大小小于索引表的表项时，那么索引表就会比文件内容还要大，对空间的利用率大大降低。

索引顺序文件是索引文件和顺序文件的结合，他也会建立一个索引表。但，他**不会为每条记录都分配一个表项**，而是**将记录们分组**，**每个分组对应着一个索引表表项**。

![image-20240614103932174](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141039546.png)

将文件的记录分完组后（右），每个组的首条记录作为索引表的表项（左）。

例中，An Qi作为该组的首条记录，被放置在索引表内。

在进行查找时，首先查看索引表的索引，根据索引找到对应组的位置。

##### 多级索引顺序文件

当文件的记录很多时，低级的索引表查找效率还是很慢。通过引入多级索引表，先分成多个低级的索引表，再用一个顶级的索引表将所有的低级索引表包含在内。

![image-20240614105207088](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141052466.png)

### 文件目录

文件目录方便用户存取/查找自己所需的文件

#### 文件控制块

每个盘符都对应着一个**目录文件**（目录表），每个表项记录着当前目录所有文件的信息（文件名，文件类型，访问权限，物理位置...）。

![image-20240614110037832](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141100209.png)

当我们双击一个文件（照片）时，操作系统会从目录文件（目录表）中，得知该文件在磁盘所对应（照片）的物理位置。操作系统会从对应（照片）的物理位置读取对应的目录文件，然后就可以将对应（照片）的文件内容显示出来。

![image-20240614110518164](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141105538.png)

目录文件的一个表项，就是一个**文件控制块**（FCB），而目录文件就是由一个或多个FCB组成。

#### 目录操作

- 搜索：系统根据文件名搜索目录文件，找到对应的目录项
- 创建文件：创建一个新文件时，需要在目录文件中添加一个文件控制块
- 删除文件：在删除文件时，不仅要删除外存块内的内容，还需要将目录文件的目录项删除
- 显示目录：用户可以请求显示目录内容，以及相对应属性
- 修改目录：修改文件的属性需要保存到目录中，例如重命名等。

#### 目录结构

##### 单级目录结构

在早期的操作系统中，整个系统只有一张目录表，每个文件占一个目录项。

这种方式实现了按名存取，但不允许文件重名。

![image-20240614111720068](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141117424.png)

当在创建一个文件时，操作系统会现在目录中检查是否有重名文件，在确定不重名的情况下才允许建立，并将新的文件对应的FBC加入目录表中。

单机目录结构不适合多用户操作系统，容易发生重名问题。

##### 两级目录结构

目录结构分为：

- 主文件目录（MFD，Master File Directory）
- 用户文件目录（UFD，User File Directory）

主文件目录（表）存放着所有的用户文件目录（表），用户文件目录存放着各个FCB。![image-20240614112041455](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141120924.png)

在不同的用户文件目录下，允许文件重名。

事实上，文件虽然重名，但对应的是不同的文件。

两级目录可以控制不同用户对别的用户的目录文件的访问限制，例如User1对User2的文件只允许读取数据，禁止别的操作。

这种结构下，每个用户的目录文件无法对文件进行分类，每个目录只允许存放文件而非目录文件。

##### 多级目录结构

为了实现每个用户对文件分类，提出多级（树形）目录结构

![image-20240614112521309](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141125907.png)

在多级目录结构下，操作系统需要提供每个文件对应的路径。

从根目录出发的路径，称为**绝对路径**。

假设读取“自拍.jpg”这个文件时，操作系统需要一级一级的向下查找，当找到对应的FCB时，获取该文件的物理磁盘块的地址，然后读取文件。因此整个过程经过了三次I/O操作。

有时，用户需要访问一个目录下的多个文件。若每次都从根目录向下查找，极大的浪费了资源。因此，我们可以设置一个**当前目录**。

从当前目录出发寻找另外一个文件时，称之为**相对路径**。

从当前目录访问相对路径后，极大减少了I/O操作的次数。

##### 无环图目录结构

在多级目录中，难以实现文件共享。

而有向无环图中，多个FCB可以包含同一个文件的物理磁盘块地址，他们允许用不同的文件名。

![image-20240614114343392](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141143844.png)

在用户删除文件时，可能会引发歧义。

因此，每个文件在共享时，会添加一个共享计数器。在一个用户删除共享文件时，操作系统会删除目录文件表对应的FCB，并且将文件共享计数器减1，其文件仍然保留在磁盘内，不会直接删除文件。

当共享计数器降为0时，操作系统才会降文件从磁盘上删除。

注意：共享文件和复制文件在本质上是不同的。共享文件只有一个文件被存放在磁盘内，而复制文件是将文件生成一个副本，使得另外一个文件目录指向该副本。

在共享文件下，用户们可以看到数据被修改。

#### 索引结点

是一种对FCB的改进

将传统的文件目录内，除了文件名以外的内容保存在一个索引结点。每个一个文件都有一个对应的索引结点。

此时，目录当中只包含了文件名和索引结点的指针。

![image-20240614115515825](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141155322.png)

##### 索引结点加速原理

假设一个FCB的大小为64B，磁盘块的大小为1KB，则一个磁盘块能够最多存放的16个FCB。当我们引用索引结点后，文件目录的表项缩小，因此一个磁盘块内可以存放更多的文件目录表项。

当操作系统需要进行一个查找操作时，一个磁盘块的内容远远多于传统的文件目录，减少了I/O操作，实现加速。

在找到对应的文件名的文件后，操作系统会将它的索引结点调入内存。

调入内存前的索引结点称为“磁盘索引结点”

调入内存后的索引结点称为“内存索引结点”，比磁盘索引结点多出了一些信息，例如文件是否被修改，几个进程正在访问该文件等。

## 文件的物理结构

文件分配方式，文件数据应该怎样存放在外存中？三种方式：

- 连续分配
- 链接分配：隐式链接，显示链接
- 索引分配

### 文件块/磁盘块

和内存分页一样，磁盘中的存储单元也被分为一个个磁盘块，在许多操作系统中，**磁盘块的大小与内存块的大小一致**，便于内存与磁盘的信息交换。

在外存管理中，一个文件可以被分别一个一个块，和内存一样，文件的**逻辑地址**也可以表示为
$$
(逻辑块号,块内地址)
$$
![image-20240614130638619](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141306031.png)

操作系统在为文件分配块时，也是按**块为单位**。

注意：**用户对文件在磁盘上的位置是不可知的**，用户只能通过逻辑地址对文件进行操作。因此，我们需要了解如何通过文件的逻辑地址转化为物理地址。

#### 连续分配

每个文件在磁盘上占有一组连续的磁盘块

![image-20240614131119532](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141311025.png)

和内存类似，我们只需要关注逻辑块号的转变，然后再和块内地址组合。

由于文件占有连续的磁盘块，因此只需要知道文件的**起始块号**和**长度**即可表达文件的所有物理地址。

在目录表中，为每个FCB引入文件的**起始块号**和**长度**（文件大小）即可。

![image-20240614131427272](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141314711.png)

所以，物理块号：
$$
物理块号=起始块号+逻辑块号
$$
当然，操作系统在访问磁盘之前，需要对用户给出的逻辑块号进行**越界验证**，若不合法则抛出异常。

由于连续分配方式，使得文件拥有连续的块。因此，这种方式**支持顺序访问和直接访问**（随机访问）。

优点：

由于是连续存放，磁头在读取的时候移动的**距离是最短的**，**读取速度最快**。

![image-20240614132347408](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141323820.png)

缺点：

1. 当文件需要拓展时，没有连续的磁盘块提供文件拓展。此时需要将整个文件转移到有足够多的空闲块的区域，再为其文件拓展空间。移动文件的成本太大。

   ![image-20240614132725654](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141327132.png)

   因此，对文件的拓展极其不方便。

2. 当磁盘没有足够的连续空间容纳一个新文件时，磁盘需要通过紧凑技术为新文件创造连续空间，开销很大。

   ![image-20240614133142170](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141331633.png)

#### 链接分配

可以为文件分配离散的磁盘块，通过指针链接将磁盘块串联起来。

链接分配分为：

- 隐式链接
- 显示链接

##### 隐式链接

在每个磁盘块中，添加一个指针，该指针**指向下一个磁盘块**。**指针对用户透明**。

在目录表中，需要添加两个元素，文件的起始块号和文件的技术块号。

![image-20240614134329973](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141343452.png)

由于是单向链表形式，所以链式分配的隐式链接模式只**支持顺序访问**，**不支持随机访问**。

当用户需要访问第i逻辑块的信息时，操作系统需要从**第0逻辑块开始**，依次向后寻找i次。因此，总共需要对磁盘进行 **i + 1 次I/O操作**。

隐式链接可以**很容易的拓展文件**，只需要将拓展的新磁盘块**接在最后一块磁盘块之后**即可。因此，**提高了磁盘利用率**，**不会有磁盘碎片问题**。

##### 显示链接

把用于链接文的各个物理块指针**显示得放在一张表中**，即**文件分配表**（FAT，File Allocation Table）。

在**文件目录表**中，只需要记录文件所对应的**起始块号**。然后**根据FAT**查找每个磁盘块的**下一块磁盘块**。

![image-20240614135945099](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141359529.png)

当一块磁盘块**没有下一块**时，则用**-1**来表示自己为**最后一块**。

注意：一个磁盘仅设置一张FAT表。在系统开机时，将FAT读入内存，并**常驻内存**中。FAT的各个表项在**物理上连续存储**，由于**每个表项长度相同**，因此“物理块号”字段可以时**隐含**的，可以通过公式计算。

###### 逻辑块号到物理块号的转变

当用户给出要访问文件的逻辑块号i时，操作系统找到该文件对应的目录项（FCB）。

在FCB中得到该文件的**起始块号**后，对起始块号**进行遍历**，每查找一次FAT表项时，i--。当i为0时，若物理块存在，则代表访问合法，直接从FAT表中读取物理地址，访问内存。

由于**遍历操作是在内存上进行**的，**整个流程不需要进行I/O操作**，**提高访问速度**。

同样，这种方式也**不会产生外部碎片**，可以很**方便的进行文件拓展**。

缺点：FAT需要**占用一点的存储空间**。

#### 索引分配

索引分配允许文件**离散地分散在磁盘中**，系统会**为每个文件建立一张索引表**，索引表记录了文件的各个**逻辑块对应的物理磁盘块**。

![image-20240614142102750](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141421243.png)

- 存放索引表的磁盘块称为“索引块”

- 存放数据的磁盘块称为“数据块”

在目录文件中，每个FCB要记录自己的索引块位置。

![image-20240614142529318](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141425841.png)

![image-20240614142803212](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141428606.png)

索引表中的逻辑块号也可以隐式表达，因为物理块号的大小一致。因此只有对应的磁盘块号才占用空间

##### FAT和索引分配的区别

FAT是一张表对应一个磁盘，而索引分配则是对应一个文件。

##### 逻辑到物理

1. 操作系统先找到用户要访问的文件的FCB
2. 根据FCB获取该文件的索引块
3. 通过公式计算，计算出逻辑块号i所对应的物理块号

和FAT不同的是，索引表的查询并不需要遍历，只需要根据公式即可马上得出用户所要访问的物理块号，即**支持随机访问**。

同时，文件的**拓展也很容易实现**，只需要在索引表内添加一个表项即可。

问题：

假设一个磁盘块的大小为1KB，索引表项为4B，则一个磁盘块能存放
$$
2^{10}B \div 2^2B = 2^8 \rightarrow 256个索引项
$$
如果一个文件较大，超过了256个磁盘块，那么一个磁盘块装不下该文件的整张索引表。应该如何解决？

答：

- 链接方案
- 多层索引
- 混合索引

##### 链接方案

为较大的文件提供多个索引块，索引块之间用指针链接。

![image-20240614144644079](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141446618.png)

FCB中任然只需记录文件的第一个索引块。

那么问题来了，当用户需要访问第二个索引块内的地址时，应该怎么办？

操作系统只能依次读取索引块，直到找到自己所需的索引块，在提取出需要的物理地址。

这显然是很低效的，因此提出多层索引。

##### 多层索引

类似多级页表，建立多层索引表。

一级索引包含所有二级索引的指针，每个二级索引指向一个物理块。

在FCB中，记录的不再是第一个索引块，而是**一级索引表的起始地址**。

![image-20240614145639384](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141456840.png)

若采用多级索引表，根据例子中，每个索引项指向一个1KB的磁盘块。因此文件的最大长度（大小）为：
$$
256_{一级索引表长度}\times256_{二级索引表长度}	\times1KB_{单位磁盘块容量} = 65536KB \rightarrow 64MB
$$

###### 逻辑到物理

例：当用户需要访问文件的1026逻辑块号
$$
1026_{虚拟块号} / 256_{二级索引表长度} = 4_{一级索引表角标}
$$
有了一级索引表的角标后，还任需要二级索引表的角标，
$$
1026_{虚拟块号} \% 256_{二级索引表长度} = 2_{二级索引表角标}
$$
所以，操作系统先访问**FCB中提供的一级索引表**（1），通过**角标读取二级索引表**（2），在通过角标得到需要访问的虚拟块号的**物理地址**（3）。因此，访问目标数据块需要**3次磁盘I/O操作**。

当一个操作系统采用**K层索引结构**时，则一个文件的**最大容量**可为
$$
索引表长度^K \times 磁盘块容量 = 文件最大容量
$$
则**访问磁盘次数**为
$$
K + 1_{获取顶层索引表} = 访问磁盘数 
$$
缺点：

当一个文件很小时，若采用多层索引方式时，仍然需要对磁盘进行K+1次I/O操作。

为了解决这个问题，提出混合索引方案。

##### 混合索引

是多种索引方式的结合，在一个顶级索引中，可以包含**直接地址索引**，也可以包含**一级间接索引**、**二级间接索引**等等。

![image-20240614151801785](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141518358.png)

一级间接索引：指向一个单层索引表

二级间接索引：指向一个两层索引表

![image-20240614152046353](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141520949.png)

## 文件存储空间管理

- 存储空间的划分与初始化
- 几种管理方法

### 存储空间的划分与初始化

例如在安装Windows操作系统时，需要对磁盘进行划分：C、D、E盘等。

这些划分也称为文件卷，逻辑卷，逻辑盘等。

在划分完文件卷后，在每一个文件卷内划分**目录区**和**文件区**。

![image-20240614160426472](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141604245.png)

目录区：存放目录文件FCB

文件区：存放文件数据

在一些操作系统中，还能够支持将不同的物理磁盘合并成一个文件卷。

![image-20240614160709926](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141607477.png)

### 文件空间管理方法

- 空闲表法
- 空闲链表法
- 成组链接法



#### 空闲表法

操作系统建立一张**空闲表**，该空闲表包含了**一段连续的空闲空间**的**第一个空闲块号**，以及该连续空间含有的**空闲块的数量**。

![image-20240614161124135](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141611686.png)

这种方法适用于**连续分配方式**，同样适用首次适应、最佳适应、最坏适应、邻近适应等算法。

假设操作系统需要为一个文件分配3个连续的磁盘块，且调用首次适应算法。

操作系统读取空闲盘块表，从低地址依次向上寻找，第一个满足的空闲盘块号开始，分配三个空闲块给该文件。分配完后，需要将空闲盘块表的信息进行修改。

![image-20240614161804462](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141618111.png)

在回收磁盘块时，需要注意对空闲盘块表的修改，以下列出四种情况：

1. 回收的磁盘块前后没有空闲区。

   则在表中建立一个新的表项

2. 回收的磁盘块前后都是空闲区。

   则需要将它们合并成一个大空闲区，此时回减少表中的一个表项

3. 回收的磁盘块前是空闲区。

   在对应的表项添加空闲盘块数量即可

4. 回收的磁盘块后是空闲区。

   则修改第一个空闲盘块号，同时修改空闲盘块数

#### 空闲链表法

- 空闲盘块链：以**块为单位**组成一条空闲链
- 空闲盘区链：以**区为单位**组成一条空闲链，区是一块或一段**连续的空闲块**组成，第一块空闲盘会记录当前**空闲区的长度**以及**指向下一个区的指针**

![image-20240614163034412](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141630924.png)

##### 空闲盘块链

操作系统会通过两个指针记录链头和链尾。

- 分配：假设分配k块空闲盘块

从链头开始，向后遍历k下，被遍历的空闲盘块分配给文件，并将链头指针指向后续空闲盘第一个块空闲块。

- 回收

从链尾开始，依次将磁盘块接在链尾指向的空闲块，最后一个回收的空闲块称为新的链尾。

![image-20240614163722312](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141637847.png)

这种方法适用于离散分配的物理结构。

##### 空闲盘区链

和空闲盘块链一样，操作系统需要通过链头和链尾两个指针。

- 分配

在分配时，可以采用首次适应、最佳适应等算法，从链头开始遍历，找到符合的连续空闲区。

如果没有连续的空闲区满足分配，也可以离散的分配小型连续的空闲区。

分配完后，可能需要修改链间空闲区的指针，以及链头链尾。

- 回收

1. 当回收区附近没有空闲区，则作为一个新的连续区接到链尾
2. 如果有，则合并到附近的空闲区，注意修改合并后的连续区指针。

这种方式，**离散和连续**分配都适应，且效率更高。

![image-20240614164640381](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141646939.png)

#### 位示图法

将整个磁盘块以二进制来表示

- 1：以分配
- 0：空闲块

每16块组成一个字（word/parola），可以理解为一组物理块。

![image-20240614165327834](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141653379.png)

每个物理块可以以如下形式表示
$$
(行号，列号)
$$
当给定一个坐标时，我们可以快速计算出所对应的物理块号。

例如：（3，2）
$$
3_{行}\times	16_{字长} + 2_{列号} = 50号磁盘块
$$
相反，可以通过相除和取余获得行号和列号

##### 分配与回收

- 分配：假设要分配K个空闲块

按顺序扫描位示图，找出K个0，分配给文件，并根据这些0的坐标得出物理块号。分配后，需要将这些0设置为1。

- 回收：

根据回收的盘块号计算对应的行号和列号，并将他们置为0

#### 成组链接法

空闲表法和空闲链表法不适用于大型文件系统，因为空闲表活空闲链表可能过大。

成组链接法在文件卷的目录区中，专门用一个磁盘块作为“**超级块**”，在系统启动时需要将超级块读入内存，并且保证内存与外存中的超级块信息始终保持一致。

![image-20240614172002390](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141720971.png)

超级块：记录了**当前组空闲盘块的数量**，以及这些**空闲盘块的块号**。

![image-20240614172248625](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141722189.png)

300：当前组空闲盘的第一个块号

100：当前这组剩余的空闲块

400：下一组空闲盘的首个空闲块，其400意味着下下组的首个空闲盘块号

![image-20240614172707994](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141727712.png)

当接下来的某一组的首个空闲块内指向-1时，意味着这是**最后一组空闲块组**。且最后一组空闲块别其他组的块要少，因为**-1不能作为一个空闲块分配给文件**。

通常，每个组的空闲块数量**都有一个上限**。（例中为100）

##### 分配与回收

- 分配

若当前组的**空闲块数大于文件所需的块数**时，将当前分组内的空闲块分配出去即可。

若当前组的空闲块等于文件所需块数时，**在分配该组最后一块空闲块之前**，需要将**下一组空闲块组信息复制到超级块内**

![image-20240614173921358](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141739165.png)

然后再将最后一块分配出去。此时**超级块内含有下一组空闲块信息**。

![image-20240614174110404](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141741996.png)

注意：在使用下一组空闲块时，务必需要将下一组的信息**先保存**到超级块中。**分配**完后分配出当前组的最后一块空闲块，然后**开始使用下一组空闲块**。

- 回收

若当前分组**还未达到上限**时，回收后的空闲块**记录在当前分组下**，并**修改**超级块内**当前组空闲块的数量**。

若当前分组**达到上限且仍需要回收空闲块**时，操作系统会**创建一个新的分组**，将达到**上限的分组信息**记录在**新分组的第一块空闲块**内。

![image-20240614175536429](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141755235.png)

## 文件的基本操作

- **创建文件**，通过create系统调用创建
- **读文件**，将文件数据读入内存，才能让CPU处理。双击文件后，操作系统通过调用read系统调用，将文件数据从外存读入内存，并显示在屏幕上
- **写文件**，在我们按下保存按钮后，操作系统会调用write系统调用，将修改后的文件数据从内存写回外存
- **删除文件**，操作系统通过调用delete系统调用从外存删除文件
- **打开文件**，系统调用open，在读写文件之前，需要打开文件
- **关闭文件**，系统调用close，在读写结束后调用

### 创建文件

在进行create系统调用时，需要提供几个主要参数：

- 所需的外存空间大小，例如一个盘块（1KB）
- 文件存放路径
- 文件名

操作系统在调用create系统调用时，主要做了两件事：

1. 在外存中找到文件**所需的空间**（空闲链表法，位示图法，成组链接法等策略来寻找空闲空间）
2. 根据文件存放路径信息，在对应的文件卷（盘符）找到**对应的文件目录**，在里面**添加新建文件的FCB**（文件名，外存物理位置等）。

### 删除文件

调用delete系统调用，需要提供：

- 文件路径
- 文件名

1. 操作系统根据路径找到目录文件，从目录文件内找到对应的文件名的FCB。
2. 根据FCB保存的物理地址和文件大小等信息，回收文件占用的磁盘块。（空闲表法，空闲链表法，位示图法等策略，根据不同策略做不同的处理）。
3. 回收完物理磁盘块后，将对应的FCB删除。

### 打开文件

open系统调用，需要提供：

- 文件路径
- 文件名
- 对文件操作的类型，例如：只读r，只写w，读写rw等。

操作系统在处理open系统调用时，主要做了几件事：

1. 根据文件存放路径找到相对应的目录文件，从目录文件中找到文件名对应的FCB，并检**查用户是否有指定的操作权限**。（访问信息记录在FCB内）

2. 若没有权利进行操作，操作系统拒绝用户请求；

   反之，操作系统将目录项FCB复制到内存中的“打开文件表”中

   ![image-20240614181823519](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141818418.png)

   打开文件表的作用：当用户在后续需要对该文件进行操作时，打开文件表会返回文件的“索引号”，即“文件描述符fd”，只需根据文件描述符进行操作，无需再通过文件目录查询，提高文件访问速度。

#### 打开文件表

进程和操作系统打开文件表不同。

操作系统：只有一张打开文件表，记录着被打开的文件

用户进程：每个用户进程都有一张属于自己的打开文件表，表项指向操作系统的打开文件表表项。表项含有读写指针（当前读写文件的位置）、访问权限（r、w、rw等）。

当一个用户尝试删除一个被别的用户或进程打开的文件时，系统会检查打开文件表，若文件被打开，则提示无法删除。

![image-20240614182608000](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141826554.png)

### 关闭文件

操作系统调用close系统调用，主要做了几件事：

1. 将进程的打开文件表相应的表项删除。
2. 回收分配给该文件的内存等资源
3. 在系统的打开文件表的打开计数器做--操作，如果为0，则删除对应表项

![image-20240614183359050](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141833692.png)

### 读文件

read系统调用需要提供的参数：

- 文件描述符，指明要读取哪个文件
- 读取的内容大小
- 从哪个位置开始读取信息
- 指定将读取的内容放在内存的位置

### 写文件

write系统调用，需要提供的参数：

- 要写入的文件名
- 写回多少数据（数据大小）
- 写回外存的数据在内存中的位置

操作系统根据参数，从内存中找到要回写的数据，以及数据大小，再根据打开文件列表，根据提供的文件名找到对应表项，再根据表项内的读写指针（指向外存）开始进行写操作。

## 文件共享

- 基于索引结点的共享方式（硬链接）
- 基于符号链的共享方式（软链接）

值得注意的是：共享文件在系统中只有一份文件数据，而复制有多份内容相同的数据。

### 索引结点的共享方式（硬链接）

索引结点本身是对文件目录表的一种瘦身策略，使得文件目录表只有文件名和索引结点指针两个元素。

为了使得文件能够被共享，允许多个FCB指向同一个索引结点，此时，需要在索引结点内添加一个计数器，来记录有几个用户/进程在共享此文件。

![image-20240614185643297](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141856142.png)

当另外一个用户也访问了该文件时，此时索引结点内的计数器进行++操作。

![image-20240614185749528](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141857236.png)

在不同的文件目录下，被共享的文件可以拥有不同的文件名。

在一个用户删除共享文件时：

- 若目前只有一个用户独享该文件，则直接删除该文件。
- 若有多个用户共享该文件，操作系统只会将当前用户的文件目录内删除FCB表项，再对其索引结点内的计数器进行--操作。

### 符号链的共享方式（软链接）

通过创建Link形文件（记录文件存放的绝对路径），该类型文件类似Windows操作系统内的快捷方式。

当用户通过该link文件访问共享文件时，会根据记录的文件路径来访问该文件。

![image-20240614190521541](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406141905157.png)

当原文件被删除时，则link文件无法根据路径找到共享文件，则软链接失效。

## 文件保护

保护文件数据的安全

- 口令保护
- 加密保护
- 访问控制

### 口令保护

文件的主人可以为文件设置一个“口令”（密钥），该口令会被保存在FCB中，用户请求访问该文件时，需要提供正确的口令。

优点：口令的空间开销不大，验证口令的时间开销也很小

缺点：口令时存放在系统内部的，如果系统被入侵，入侵者即可获得口令随意访问文件。

### 加密保护

使用某个“密码”对文件进行加密，在访问文件时需要提供正确的密码，才能对文件进行正确的解密。

例：一个简单的加密算法-->异或加密（相同为0，不同为1）

假设用于加密/解密的密码为 “01001”

将原始数据的二进制码与 提高的加密密码“01001”进行异或运算，得到异或后的二进制码，将该二进制码作文文件存放在磁盘。

![image-20240615092616378](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406150926883.png)

当用户需要对文件进行解密时，需要提供正确的加密密码，进行解密。若提供的加密密码不正确，则会是一串无意义的二进制码。

![image-20240615092707770](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406150927288.png)

优点：保密性强，不需要在系统中存储“密码”

缺点：在加密/解密的过程需要花费一定的时间

### 访问控制

系统在每个文件的FCB或索引结点中，增加一个**访问控制表**（Access-Control List, ACL），该表中记录了各个用户可以对文件执行哪些操作。

#### 访问类型

- 读
- 写
- 执行
- 添加：将新的信息添加到文件结尾部分
- 删除：删除文件，释放空间
- 列表清单：列出文件名和文件属性

1表示允许，0表示拒绝

![image-20240615093300813](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406150933381.png)

有的计算机可能会有很多歌用户，因此访问控制表可能会很大，可以通过精简访问控制表解决这个问题。

#### 精简访问控制表

将访问控制表以**组为单位**，标记各组的用户可以对文件执行哪些操作。

例如：分为 系统管理员，文件主，文件主的伙伴，其他用户 等几个分组

![image-20240615093659879](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406150937479.png)

## 文件系统的层次结构

![image-20240615094659101](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406150946592.png)

- 用户接口：文件的基本操作
- 文件目录系统：文件目录
- 存取控制模块：文件保护
- 逻辑文件系统与文件信息缓冲区：文件逻辑结构
- 物理文件系统：文件物理结构
- 辅助分配模块：文件存储空间管理
- 设备管理模块：磁盘管理

用一个例子来理解整个流程

假设用户请求删除文件 “D:/File/学生信息.xlsx”最后100条记录。

1. 用户需要通过操作系统请求删除系统调用。（用户接口）
2. 操作系统根据路径，一层一层的找到该文件对应的文件目录表，以及它的FCB。（文件目录系统）
3. 通过FCB查看当前用户对此文件的访问权限。（存取控制模块）
4. 验证完访问权限后，在根据用户提供的记录号（即100条记录的记录号），将其转变为逻辑地址。（逻辑文件系统与文件信息缓冲区）
5. 得知逻辑地址后，将逻辑地址转换为物理地址。（物理文件系统）
6. 明确要删除某条记录时，需要向磁盘设备发送删除请求。（设备管理程序模块）
7. 删除后需要对这些空闲磁盘块进行回收。（辅助分配模块）

## 文件系统的全局结构（布局）

### 文件系统在外存建立的过程

1. 在磁盘**刚被生产**出来时，**内部没有划分扇区**。因此，需要对磁盘进行**物理格式化**。

   **物理格式化**：对磁盘进行**扇区划分**，同时**检查扇区是否损坏**。如果损坏，则**启用备用扇区进行替换**。扇区替换是对操作系统**透明**的，操作系统无法感知。

   ![image-20240615100620872](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151006627.png)

2. 逻辑格式化：将磁盘进行分区（分卷 Volume），每个分区的起始地址和结尾地址都会被存放在分区表中。

   ![image-20240615101404292](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151014771.png)

   在每个分区内，可以建立不同的文件系统。

3. 假设在C盘内建立了一个UNIX文件系统，需要在C盘内初始化。

   引导块：负责开机初始化操作系统

   超级块：寻找空闲块分组

   空闲空间管理：位示图（0101001...）

   索引结点区：文件的索引结点，在UNIX中，所有的索引结点连续的存放在这个区内（类似Array）。

   根目录：用于建立下一级目录或存取新的文件

   ![image-20240615102046379](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151020931.png)

   白色部分为空闲块

### 文件系统在内存中的结构

- **目录缓存**：操作系统在访问一个文件后，会将该文件的目录文件表存放在内存中，即**目录缓存**。在下次访问同目录下的文件时，则直接从该缓存内读取数据。
- 系统打开文件表
- 进程（用户）打开文件表

![image-20240615102607557](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151026196.png)

例：open系统调用的过程。

1. 操作系统会根据文件路径这个参数，找到该文件对应的文件目录，将该文件目录缓存在内存中。

![image-20240615103159188](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151031681.png)

2. 在文件目录表中，找到对应的FCB，并复制的操作系统的打开文件表（唯一），同时设置打开计数为1。除此之外，请求系统调用的进程（用户）会在内存中的进程（用户）打开文件表内新建一个表项，记录该进程（用户）对此文件的打开方式（读、写等），且指向系统打开文件表内的刚被复制的表项。

![image-20240615103335828](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151033250.png)

![image-20240615104430631](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151044142.png)

3. 处理完打开文件表后，会返回给用户打开文件表的索引（文件描述符fd）。根据这个描述符，用户可以对文件进行相应的操作。

![image-20240615104552694](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151045670.png)

假设用户需要读取一个文件的内容时，通过系统调用read，传入文件描述符fd。

```c
read(fd,xxx,xxx);
```

操作系统会根据文件描述符，在进程（用户）的打开文件表内，找到指向系统打开文件表的索引号，根据索引号再查找系统打开文件表获取文件的FCB。

FCB包含了该文件的物理磁盘地址，即可实现对文件的读操作。

![image-20240615105119395](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151051870.png)

## 虚拟文件系统&文件系统挂载

当操作系统接入了不同的外存时，每个外存的文件系统可能并不相同。取决于外存大小和开发者策略。

![image-20240615105547674](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151055195.png)

每个文件系统的文件操作函数可能不相同，当用户需要对一个外存进行操作时，需要调整操作函数，这是相当麻烦的。

因此，引入**虚拟文件系统VFS**来解决该问题。

![image-20240615105827026](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151058608.png)

### 虚拟文件系统

向上次用户进程提供了统一标准的系统调用接口

下层的文件系统，必须实现虚拟文件系统的接口函数。如果不实现，则该文件系统不被此操作系统支持。

当我们想要建立一个文件系统时，必须实现操作系统提供的接口。

由于不同的文件系统返回的目录项不同，例如：UFS 返回的是一个索引结点（目录表的瘦身形态）；FAT返回一个目录表等。

![image-20240615111246881](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151112424.png)

为了统一，操作系统会在内存内为**每个文件都建立一个vnode**，里面包含了**文件的信息**，以及该文件所对应的文件系统的各种**功能函数指针**。

函数功能指针：根据文件所在的文件系统，指向该文件系统的所使用的函数。

![image-20240615111536046](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151115558.png)

### 文件系统挂载（mounting）

文件系统的安装，如何将一个文件系统安装到操作系统中。在平时生活中，当我们把一个U盘插入电脑时，需要将U盘的文件系统，挂载到虚拟文件系统中。

挂载步骤：

1. 在VFS中注册新的挂载文件系统。在内存中存放着一个**挂载表**（mount table），该表包含了文件系统的相关信息，例如文件系统类型，容量大小等。注册时，需要在挂载表内添加一个新的表项。
2. 新挂载的文件系统，需要向VFS提供一系列操作文件的**函数地址**。
3. 将新的文件系统添加到**挂载点**（mount point），也就是添加到某个根目录下，用于进入新接入的外存，进行各种操作。

![image-20240615112515857](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151125377.png)

在Windows中，挂载点与各个盘符平级，同在我的电脑下。

在Mac中，挂载点为Volumes这个文件夹下。

# 设备管理

操作系统对主机外部硬件的管理

## I/O设备的基本概念与分类

### I/O设备

- I：input

- O：output

I/O设备就是将数据输入到计算机，或接收计算机输出数据。

### I/O设备的分类

- 人机交互类：鼠标键盘，这种设备传输速度较慢
- 存储设备类：硬盘，光盘，这种设备传输速度较快
- 网络通信设备：路由器等，这种设备传输速度介于人机与存储之间

按速度分类：

- 低速
- 中速
- 高速

按信息交换的单位分类：

- 块设备：传输速度较快，可寻址
- 字符设备，船速速度慢，不可寻址。在I/O时采用中断驱动方式

## I/O控制器

I/O设备是由**机械部件**和**电子部件**（I/O控制器、设备控制器）组成。

CPU无法直接控制机械部件，例如令屏幕的某个像素点发亮。需要通过电子部件（I/O控制器）来控制机械部件。电子部件作为CPU和机械部件的一个中转站。

因此，I/O控制器需要和CPU进行对接，需要满足以下功能：

- 接受和识别CPU发出的命令（读写命令等），需要通过**控制寄存器**来存放命令和参数。
- 向CPU报告设备的状态，通过**状态寄存器**来记录设备状态，例如：1为空闲，0为忙碌。
- 数据交换，通过**数据寄存器**，在接收数据时，先暂存在数据寄存器内，再传达给设备；输出时，设备向将数据保存着寄存器内，再发送给CPU。
- 识别地址。I/O设备内的寄存器是有编址的，I/O设备通过识别CPU发送来的地址，来决定对哪个寄存器进行操作。

### I/O控制器的结构

![image-20240615120316699](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151203335.png)

- 控制线：CPU向I/O设备发出的具体的I/O指令
- 地址线：说明自己需要操控哪一个设备
- 数据总线：从I/O设备输入/读取数据
- 控制：根据CPU的指令，设备执行特点的操作

注意：

1. 一个I/O控制设备可以对应多个I/O设备
2. I/O控制器内可能存在多个寄存器，这些寄存器都需要有相对应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，即为**内存映像I/O**；有的计算机采用I/O专用地址，即**寄存器独立编址**。

#### 内存映像I/O vs 寄存器独立编址

内存映像I/O：若内存的编址从0到N-1，则设备控制器会沿用内存的地址，从N开始编址。

![image-20240615121557804](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151215744.png)

这种方式简化了CPU对设备控制器的操作。

寄存器独立编址：每个设备控制器内的寄存器编址不基于内存的地址，有着自己独有的编址。设备控制器们的寄存器可以是连续编址，或者是各自从0地址开始编址。

![image-20240615121738132](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151217956.png)

这种方式存在着缺点，需要通过专门的指令来实现对寄存器的控制，不仅需要寄存器的地址，还要指明寄存器的编号。

## I/O控制方式

- 程序直接控制方式
- 中断驱动方式
- DMA方式
- 通道控制方式

学习注意事项：

1. 一次读写操作的流程
2. CPU干预的频率
3. 数据传输的单位
4. 数据流向
5. 各种方式的优缺点

### 程序直接控制方式

- 流程：以读取为例

  1. CPU向控制器发出读指令，I/O控制器启动设备，并将状态寄存器设为1（未就绪）。此时，设备**正在启动**（未就绪）。

     ![image-20240615134556145](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151345745.png)

  2. 在设备尚未就绪前，CPU会不断地向I/O设备**轮询检查**设备的状态（状态寄存器），轮询时，若设备出现错误，会将错误信息写入状态寄存器内。CPU读到错误信息就会进行相应操作。

     ![image-20240615134852123](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151348696.png)

  3. 当设备准备好数据时，将数据（一个字，取决于操作系统架构，32位计算机，一个字等于4Byte，64位，一个字等于8Byte）传给I/O控制器，并且报告自身的状态。

     ![image-20240615135149724](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151351266.png)

  4. I/O控制器在接收到数据和状态后，将数据传入数据寄存器，并将状态寄存器的值修改为0（已就绪）。在此期间CPU仍然还在对I/O控制器进行轮询。

     ![image-20240615135429362](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151354000.png)

  5. 当CPU发现I/O控制器已经就绪时，就会将数据寄存器内的数据保存在自己的寄存器内，再放入内存中。

  6. 若CPU任需读取数据，就会从控制线内再发送一条读取指令，循环步骤。

这种方式，CPU的干预的很频繁，在向I/O控制器请求一次操作后，不断地向I/O控制器询问是否就绪。

传输单位：1字

数据流向：

- 读：I/O设备 -> CPU -> 内存
- 写：内存 -> CPU -> I/O设备

优缺点：

优点：实现简单，轮询可以以软件的形式完成，while循环等。

缺点：CPU在轮询过程不能做其他的工作，要一直等待I/O设备完成操作，使得CPU一直处于忙等状态（busy wait）降低CPU的利用率。

### 中断驱动方式

引入中断机制，在CPU向I/O控制器发送指令后，可以去完成别的工作，直到I/O设备完成操作。

I/O设备完成操作后，向CPU发出一个中断信号。CPU检测到中断信号后，会保存当前运行的进程的环境信息（寄存器等），使其进入阻塞态，再回头处理中断。

CPU从I/O控制器内读取一个字的数据，保存着CPU寄存器内，再写入内存。

写入完成后，CPU可以选择恢复先前陷入阻塞太的进程，或者处理别的进程。

注意：

- CPU会在每个指令周期的末尾检查中断
- 中断的处理过程需要保存和恢复进程的运行环境。若中断太频繁，保存和恢复开销太大，降低系统性能。
- 每次处理一次中断只会读取**一个字的数据**，如果需要读入大量的数据，CPU会不断的发生中断。

引入中断后，CPU的干预频率下降。

数据流向：

- 读：I/O设备 -> CPU -> 内存
- 写：内存 -> CPU -> I/O设备

优缺点：

优点：解决了程序直接控制访问的缺点，CPU可以和I/O设备并行执行。CPU也不再需要一直对I/O控制器轮询。

缺点：由于每次传输只有一个字，且都得经过CPU，频繁的中断处理会消耗CPU较多的时间。

### DMA方式

直接存储器存取（DMA，Direct Memory Access）。

相较于先前两种方式，DMA的数据传输单位为“**块**”，而不再是一个字。

数据流向不需要再经过CPU，而是从设备直接放入内存，或从内存直接输入到设备。

CPU对I/O操作干预频率降低，只需要在传输的开始和结束时干预即可。

流程：

1. CPU向I/O模块发出指令，CPU需要指出进行的操作，操作的数据量，操作的位置等，然后继续完成其他工作
2. DMA根据CPU发出的指令完成一些列的读写操作。
3. 当DMA完成读写操作时，DMA向CPU发送一个中断请求。

![image-20240615143830801](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151438670.png)

数据流向：

- 读：I/O设备  -> 内存
- 写：内存  -> I/O设备

优缺点：

优点：数据的传输以块为单位，CPU的干预频率进一步降低，数据的传输不用再经过CPU，增加传输效率，CPU和I/O设备的性能得到提升。

缺点：CPU每发出一条I/O指令，只能读写一个或者多个连续的数据块。如果读写多个离散的存储数据块，或将数据离散的分配到不同的空间时，CPU需要分别发出多条I/O指令，这也意味着需要多次处理中断请求。

### 通道控制方式

通道：一种硬件，可以理解为一个“弱鸡版的CPU”，通过可以识别并执行一些列的通道指令。**为什么是一个弱鸡版CPU？**

因为通道这个硬件**拥有自己的指令集**，相比于CPU，自己的指令集非常小且简单。

流程：

1. CPU向通道发送I/O指令，指明通道程序（指令的序列）存放在内存的哪个位置。同时，也需要指出要操作的是哪些I/O设备。CPU发送完指令后，便可去处理其他任务。

   ![image-20240615144954080](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151449775.png)

2. 通道会根据CPU指出的内存位置，在内存中找到通道程序（读写多少数据，读写数据指明的位置等信息）

   ![image-20240615145342393](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151453111.png)

   这里要注意：对I/O设备的操作并不是CPU直接告诉通道，CPU将一系列对I/O设备的操作以清单形式存放内存中。CPU告诉通道清单的内存位置，由通道去CPU读取清单，并对执行相应操作。

3. 当通道执行完清单内的操作时，向CPU发出一个中断请求。

CPU的干预频率进一步降低，CPU可以一次性扔出很多个I/O操作指令给通道，只需要在开始和结束干预即可。

数据流向：

- 读：I/O设备  -> 内存
- 写：内存  -> I/O设备

优缺点：

优点：CPU、通道、I/O设备可以并行工作，提高资源利用率

缺点：实现复杂，需要专门的硬件支持。

## I/O软件层次结构

![image-20240615150534737](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151505421.png)

### 用户层软件

在用户请求I/O操作时，可以使用用户层软件提供的一些库函数。

例：在c语言中，如果我们想打印某些字符，需要通过stdio.h库函数的printf函数来实现。

### 设备独立性软件

又称为与设备无关性软件，为什么无关？

该层实现了硬件没有实现的功能：

1. 向上层提供系统调用，同时保护设备。

2. 设备会被看作为一种特殊的文件，不同用户对各个文件的访问权限不同，对设备也是如此。

3. 差错处理，该层还需要处理一些设备错误。

4. 设备的分配与回收，设备是一种临界资源。

5. 数据缓存区管理，处理设备之间的数据交换单位大小和传输速度差异。

6. 建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序。

   例：当我们通过一台计算机打印某些内容时，操作系统需要让我们选择打印设备，其显示的名字即为逻辑设备名。操作系统需要知道每个逻辑设备名所对应的物理设备名。

   而这种映射关系需要通过逻辑设备表（LUT，Logical Unit Table）来记录，并且找到设备对应的设备驱动程序。

   ![image-20240615152549389](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151525036.png)

#### 逻辑设备表

采用两种方式管理：

- 整个系统只有一张LUT：着意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。
- 为每个用户都设置一张LUT：允许用户之间的逻辑设备名重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。

### 设备驱动程序

为什么每个设备都需要不同的设备驱动程序？

因为每个设备的内部构造大不相同，且设计时采用的架构不同，只有生产者才知道他们的产品怎么才能正常运行。因此需要特有的设备驱动程序才能够正常运行。

在设备被生产时，通常厂家会提供该设备的驱动程序。

当CPU需要使用该设备时，操作系统只要执行该设备的驱动程序即可。

通常设备驱动程序会以一个独立进程的方式存在。

### 中断处理程序

当I/O设备完成任务时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。

流程：

![image-20240615153851472](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151538278.png)

### 输入/输出应用程序接口&设备驱动程序接口

#### 应用程序接口

- 字符设备接口：get/put系统调用，向设备读/写一个字符

- 块设备接口：read/write系统调用，指明从哪个文件的哪个位置（seek）读写多少个字符

- 网络设备接口：socket系统调用，创建一个网络套接字，指明网络传输协议，返回一个文件描述符，指向建立的网络套接字；

  bind：将套接字绑定到某个本地端口（port）

  connect：将本地的套接字绑定另一个主机的套接字，需要提供IP地址

  read/write：对套接字进行读写

![image-20240615160034681](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151600344.png)

#### 阻塞I/O & 非阻塞I/O

阻塞：在应用程序发出I/O系统调用，进程需要转为阻塞状态。例：scanf函数。

非阻塞：应用程序发出I/O系统调用，系统调用可以迅速返回，进程无需进入阻塞状态等待。

#### 设备驱动程序接口

操作系统会统一一个设备驱动的接口，生产商需要对这个接口实现各种方法。

## I/O核心子系统

I/O软件的层次结构中，其中：

- 设备独立性软件
- 设备驱动程序
- 中断处理程序

这三层是属于操作系统的内核部分，也称为I/O核心子系统。

操作系统的各种技术需要在不同层级完成：

- SPOOLing技术（假脱机技术）：在用户层软件实现
- I/O调度、设备保护、设备分配与回收、缓冲区管理（缓存与高速缓存）：设备独立性软件实

### 假脱机技术SPOOLing

#### 脱机技术

在远古时代，程序员需要将自己写好的程序以纸带的形式输入到电脑内。纸带机的读取速度远远慢于CPU，存在着巨大的速度差。

为了解决这个问题，引入了脱机技术。纸带机会优先将程序读到一个磁带中，磁带的速度比纸带机块很多。之后CPU只需要读取磁带即可，提高读取速度。

同理，CPU可以将输出的结果先输出到磁带上，纸带机再从磁带中读取结果即可。

![image-20240615163133669](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151631619.png)

脱机：脱离主机进行操作

#### SPOOLing

根据脱机技术，衍生出假脱机技术 SPOOLing技术，用软件来模拟输入和输出过程，因此操作系统需要支持多道程序技术。

![image-20240615163742018](https://raw.githubusercontent.com/Bosang6/Pic_Go_Save/main/picgo/202406151637730.png)

此时，输入井和输出井担任来磁带的角色，软件程序先将输入数据暂存在输入缓冲区内，再输入到输入井。

当CPU需要读取程序时，由于磁盘的速度大于输入设备，因此只需要读取磁盘里的内容即可。

### 设备的分配与回收

#### 设备分配的考虑因素

- 设备的固有属性：独占设备（打印机）、共享设备（磁盘、宏观层面共享，微观下交替使用）、虚拟设备（通过SPOOLing技术，将独占设备改为共享设备，分配给多个进程）
- 设备分配算法
- 设备分配的安全性
