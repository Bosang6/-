## 算法

### 广度优先算法（BFS）

通常在cost为1时使用，该算法寻到第一最近节点。

算法过程

```
1.将一个节点放入队列中
2.查看队列，如果队列不为空，提取一个节点；若为空，结束算法
3.查看提取出来的节点是否有邻近节点，并检查是否是GOAL
	· 如果是，返回结果
	· 如果不是，将该节点的邻近节点加入队列（FIFO）
4.回到步骤2
```

时间复杂度：

时间： O（V + E）

空间：O（V）在最坏的情况下，将所有节点都加入队列中

### 最小代价搜索（UCS）

适用于路径cost不相等的情况，是BFS的一种拓展

算法过程

```
1.初始化：从初始节点开始，将其加入到一个优先队列（priority queue），这个优先队列按照从初始节点到当前节点的路径代价进行排序
2.
```

### 深度优先搜索（DFS）

该算法沿着树的深度遍历树的节点，尽可能深得搜索树的分支，直到该分支的末端节点。当该分支完成搜索完以后，返回初始节点，进入下一条分支，遵循LIFO队列，即stack

算法过程

```
1.选择一个节点，标记为已访问。
2.以递归的方式访问该节点的邻近节点
3.当一个节点没有邻近节点时，回溯到上一个节点，访问其他的邻近节点。直到回到初始节点
```

应用：

- 寻找图中所有连通分量
- 拓扑排序
- 寻找图中的环
- 路径查找问题（问题允许非最短路径时）
- 解决迷宫，迷宫生成问题

缺点：当一条分支的节点趋于无穷大时，可能永远无法找到GOAL或寻找代价太大

### 深度限制算法（DLS）

该算法时DFS的一种优化算法，在搜索时加入了一个深度限制，防止陷入无止尽的搜索或大代价搜索

算法过程：

```
1.开始：从起始节点开始，将其设为当前节点，且设置深度限制 L
2.检查深度：如果当前节点的深度等于L，则停止在该节点的进一步搜索（不考虑当前节点的子节点）
3.拓展节点：
 - 对当前节点，检查每个子节点
 - 如果子节点是GOAL，搜索成功结束
 - 如果子节点不是GOAL，且深度 < L，则继续对每个子节点应用DLS算法
 4.回溯：如果所有子节点被检查过，且没有找到目标节点，回溯到上一级节点
 5.结束：如果搜索树中的所有节点都在深度L之内被访问且没有找到目标节点，搜索失败。需要增加L深度
```

### 迭代加深搜索（IDS）

结合了深度优先搜索（DFS）的空间效率和广度搜索（BFS）最短路径的能力。

在每次迭代后，增加L的值

算法过程

```
1.初始化深度限制：L = 0
2.执行DLS：根据L指，执行DLS，如果找到目标，则立即返回，如果没有找到，L = L + 1
3.重复2，直到找到目标
4.终止条件：为L设定一个范围，若超过该范围，终止算法
```

特点和应用：

- 完备性：IDS是完备的，意味着如果目标存在于搜索空间中，IDS始终会找到GOAL
- 最优性：与BFS相比，当GOAL处于同一个深度时，IDS的找到GOAL的效率优于BFS，因为BFS需要遍历每一个节点，而IDS通过一个分支一个分支的访问，效率更高，但在情况最差的情况，即节点在底部的最右侧，效率相同。



你好

